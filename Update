// --- inside useEffect() ---

const load = async () => {
  let json;
  try {
    json = await fetchLiveSummary();
  } catch (err) {
    console.error("fetchLiveSummary error:", err);
    return;
  }
  if (!active) return;

  // --- 1) normalize & trim liveCounts keys ---
  const raw = json.realtime[partition]?.floors || {};
  const counts = Object.entries(raw).reduce((acc, [floor, count]) => {
    const f = (floor || 'Unmapped').toString().trim();
    acc[f] = (acc[f] || 0) + count;
    return acc;
  }, {});
  setLiveCounts(counts);

  // --- 2) grab all swipes for this partition (server already filtered Out of office floors) ---
  const all = json.details
    .filter(r => r.PartitionName2 === partition);

  // --- 3) sort oldest→newest & group to last swipe per user ---
  all.sort((a, b) =>
    new Date(a.LocaleMessageTime) - new Date(b.LocaleMessageTime)
  );
  const lastByPerson = {};
  all.forEach(r => { lastByPerson[r.PersonGUID] = r });

  // --- 4) KEEP last swipe per user (do NOT drop OutDirection), but normalize direction & attach floor ---
  const inside = Object.values(lastByPerson).map(r => {
    // normalize Direction to handle DB variants like "IntDirection" etc.
    const dirRaw = (r.Direction || '').toString().trim();
    let dirNorm = dirRaw;
    const lr = dirRaw.toLowerCase();
    if (lr.startsWith('in')) dirNorm = 'InDirection';
    else if (lr.startsWith('out')) dirNorm = 'OutDirection';
    // else keep original (fallback)

    // lookup floor (frontend util)
    const floor = lookupFloor(r.PartitionName2, r.Door, dirNorm) || 'Unmapped';

    return {
      ...r,
      Direction: dirNorm,
      floor
    };
  });

  setDetails(inside);
  setLastUpdate(new Date().toLocaleTimeString());
  setLoading(false);
};
















In Laca live Summary in Frontend Display Total 6 count but in details Section sisplay only 3 entry .
When i review and debug file there is issue in frontend display 3 entry . Which swipe Direction is "Direction": "IntDirection",
      "Floor": "Building B1"

But it remove 
"Direction": "OutDirection",
      "Floor": "Building B1"
so Basically our logic is Strickly remove Count from Realtime Details When Zone or Floor = Out  of Office only..
if Direction is InDirection or OutDirection and  floor or Zone is not equal to Out of office then dont rewmove their Count...
if Direction is InDirection or OutDirection and Floor or Zone is Out of Office then strickly remove their count from realtime Details..

so i have found this issue in laca file strickly solve this issue carefully ...
Check below Laca Controller file as well Frontend file and fix this issue carefully...


//C:\Users\W0024618\Desktop\laca-occupancy-backend\src\controllers\occupancy.controller.js


const service = require('../services/occupancy.service');
const doorMap = require('../utils/doorMap'); 



exports.getLiveOccupancy = async (req, res) => {
  try {
    const data = await service.fetchLiveOccupancy();
    res.json({ success: true, count: data.length, data });
  } catch (err) {
    console.error(err);
    res.status(500).json({ success: false, message: 'Live occupancy fetch failed' });
  }
};


/**
 * Returns true if this PersonnelType counts as Employee.
 * Everything else (including blank) counts as Contractor.
 */

function isEmployeeType(pt) {
  return pt === 'Employee'
      || pt === 'Terminated Employee'
      || pt === 'Terminated Personnel';
}

/**
 * Returns true if this PersonnelType is a Temp Badge.
 */
// function isTempBadgeType(pt) {
//   return pt === 'Temp Badge';
// }


function isTempBadgeType(pt) {
  // handle both variants from the database
  return pt === 'Temp Badge' || pt === 'TempBadge';
}



/**
 * Look up floor for a given record by matching door + partition.
 */
function lookupFloor(partition, door, direction, unmappedSet) {
  const entry = doorMap.find(d =>
    d.partition === partition && d.door === door
  );
  if (!entry) {
    unmappedSet.add(`${partition} | ${door}`);
    return null;
  }
  return direction === 'InDirection'
    ? entry.inDirectionFloor
    : entry.outDirectionFloor;
}




// exports.getLiveSummary = async (req, res) => {
//   try {
//     const swipes = await service.fetchLiveOccupancy();

//     // 1. TODAY’S HEADCOUNT: first swipe per person
//     const firstByPerson = {};
//     swipes.forEach(r => {
//       const prev = firstByPerson[r.PersonGUID];
//       const t = new Date(r.LocaleMessageTime).getTime();
//       if (!prev || t < new Date(prev.LocaleMessageTime).getTime()) {
//         firstByPerson[r.PersonGUID] = r;
//       }
//     });
//     const todayRecs = Object.values(firstByPerson);
//     const today = { total: 0, Employee: 0, Contractor: 0, TempBadge: 0 };
//     todayRecs.forEach(r => {
//       today.total++;
//       if (isTempBadgeType(r.PersonnelType)) today.TempBadge++;
//       else if (isEmployeeType(r.PersonnelType)) today.Employee++;
//       else today.Contractor++;
//     });

//     // 2. REAL-TIME: last swipe per person, only InDirection
//     const lastByPerson = {};
//     swipes.forEach(r => {
//       const prev = lastByPerson[r.PersonGUID];
//       const t = new Date(r.LocaleMessageTime).getTime();
//       if (!prev || t > new Date(prev.LocaleMessageTime).getTime()) {
//         lastByPerson[r.PersonGUID] = r;
//       }
//     });

//     const realtime = {};
//     const unmappedDoors = new Set();
//     Object.values(lastByPerson).forEach(r => {
//       // if (r.Direction !== 'InDirection') return;
//      // ● only remove if this door truly maps to "Out of office"
//      if (r.Direction === 'OutDirection') {
//        const floor = lookupFloor(r.PartitionName2, r.Door, r.Direction, unmappedDoors);
//        if (floor === 'Out of office' || floor?.trim() === 'Out of office') {
//          return; // true exit → evict
//        }
//        // otherwise fall through and count them
//      }


//       const p = r.PartitionName2;
//       // initialize, including TempBadge for CR
//       if (!realtime[p]) {
//         realtime[p] = { total: 0, Employee: 0, Contractor: 0 };
//         if (p === 'CR.Costa Rica Partition') realtime[p].TempBadge = 0;
//         realtime[p].floors = {};
//       }
//       realtime[p].total++;
//       if (isTempBadgeType(r.PersonnelType)) realtime[p].TempBadge++;
//       else if (isEmployeeType(r.PersonnelType)) realtime[p].Employee++;
//       else realtime[p].Contractor++;

//       const floor = lookupFloor(p, r.Door, r.Direction, unmappedDoors) || 'Unmapped';
//       realtime[p].floors[floor] = (realtime[p].floors[floor] || 0) + 1;
//     });

//     if (unmappedDoors.size) {
//       console.warn('Unmapped doors:\n' + Array.from(unmappedDoors).join('\n'));
//     }

//     return res.json({
//       success: true,
//       today,
//       realtime,
//       details: Object.values(lastByPerson)
//     });
//   } catch (err) {
//     console.error(err);
//     return res.status(500).json({ success: false, message: 'Live summary failed' });
//   }
// };




exports.getLiveSummary = async (req, res) => {
  try {
    const swipes = await service.fetchLiveOccupancy();

    // 1. TODAY’S HEADCOUNT: first swipe per person
    const firstByPerson = {};
    swipes.forEach(r => {
      const prev = firstByPerson[r.PersonGUID];
      const t = new Date(r.LocaleMessageTime).getTime();
      if (!prev || t < new Date(prev.LocaleMessageTime).getTime()) {
        firstByPerson[r.PersonGUID] = r;
      }
    });
    const todayRecs = Object.values(firstByPerson);
    const today = { total: 0, Employee: 0, Contractor: 0, TempBadge: 0 };
    todayRecs.forEach(r => {
      today.total++;
      if (isTempBadgeType(r.PersonnelType)) today.TempBadge++;
      else if (isEmployeeType(r.PersonnelType)) today.Employee++;
      else today.Contractor++;
    });

    // 2. REAL-TIME: last swipe per person, with strict removal for Floor == "Out of office"
    const lastByPerson = {};
    swipes.forEach(r => {
      const prev = lastByPerson[r.PersonGUID];
      const t = new Date(r.LocaleMessageTime).getTime();
      if (!prev || t > new Date(prev.LocaleMessageTime).getTime()) {
        lastByPerson[r.PersonGUID] = r;
      }
    });

    const realtime = {};
    const unmappedDoors = new Set();

    Object.values(lastByPerson).forEach(r => {
      // Resolve mapped floor up-front (populates unmappedDoors when needed)
      const rawFloor = lookupFloor(r.PartitionName2, r.Door, r.Direction, unmappedDoors);
      const floorNorm = rawFloor ? String(rawFloor).trim().toLowerCase() : '';

      // STRICT RULE: if resolved Floor equals "out of office" -> skip counting entirely
      if (floorNorm === 'out of office') {
        return;
      }

      const p = r.PartitionName2;
      // initialize, including TempBadge for CR
      if (!realtime[p]) {
        realtime[p] = { total: 0, Employee: 0, Contractor: 0 };
        if (p === 'CR.Costa Rica Partition') realtime[p].TempBadge = 0;
        realtime[p].floors = {};
      }

      realtime[p].total++;
      if (isTempBadgeType(r.PersonnelType)) realtime[p].TempBadge++;
      else if (isEmployeeType(r.PersonnelType)) realtime[p].Employee++;
      else realtime[p].Contractor++;

      // add to floor bucket, using 'Unmapped' when lookup fails
      const normFloor = rawFloor ? String(rawFloor).trim() : 'Unmapped';
      realtime[p].floors[normFloor] = (realtime[p].floors[normFloor] || 0) + 1;
    });

    if (unmappedDoors.size) {
      console.warn('Unmapped doors:\n' + Array.from(unmappedDoors).join('\n'));
    }

    // Build enriched details with Floor added, but filter out any whose Floor is "Out of office"
    const details = Object.values(lastByPerson)
      .map(r => {
        const rawFloor = lookupFloor(r.PartitionName2, r.Door, r.Direction, unmappedDoors);
        const floor = rawFloor ? String(rawFloor).trim() : null;
        return {
          ...r,
          Floor: floor
        };
      })
      .filter(d => {
        const f = d.Floor;
        return !(f && String(f).trim().toLowerCase() === 'out of office');
      });

    return res.json({
      success: true,
      today,
      realtime,
      details
    });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ success: false, message: 'Live summary failed' });
  }
};














// src/pages/PartitionDetailDetails.jsx
import React, { useEffect, useState, useMemo } from "react";
import {
  Container, Box, Typography, Button, TextField,
  TableContainer, Paper, Table, TableHead, TableRow, TableCell, TableBody
} from "@mui/material";
import { useParams, useNavigate } from "react-router-dom";

import Header from "../components/Header";
import Footer from "../components/Footer";
import LoadingSpinner from "../components/LoadingSpinner";
import DataTable from "../components/DataTable";

import { fetchLiveSummary } from "../api/occupancy.service";
import { lookupFloor } from "../utils/floorLookup";

export default function PartitionDetailDetails() {
  const { partition } = useParams();
  const navigate = useNavigate();

  const [loading, setLoading] = useState(true);
  const [details, setDetails] = useState([]);
  const [liveCounts, setLiveCounts] = useState({});
  const [lastUpdate, setLastUpdate] = useState("");
  const [searchTerm, setSearchTerm] = useState("");
  const [expandedFloor, setExpandedFloor] = useState(null);

  // pull + poll
  useEffect(() => {
    let active = true;

    const load = async () => {
      let json;
      try {
        json = await fetchLiveSummary();
      } catch (err) {
        console.error("fetchLiveSummary error:", err);
        return;
      }
      if (!active) return;

      // --- 1) normalize & trim liveCounts keys ---
      const raw = json.realtime[partition]?.floors || {};
      const counts = Object.entries(raw).reduce((acc, [floor, count]) => {
        const f = floor.trim();
        acc[f] = (acc[f] || 0) + count;
        return acc;
      }, {});
      setLiveCounts(counts);

      // --- 2) grab all swipes (in+out) for this partition ---
      const all = json.details
        .filter(r =>
          r.PartitionName2 === partition &&
          (r.Direction === "InDirection" || r.Direction === "OutDirection")
        );

      // --- 3) sort oldest→newest & group to last swipe per user ---
      all.sort((a, b) =>
        new Date(a.LocaleMessageTime) - new Date(b.LocaleMessageTime)
      );
      const lastByPerson = {};
      all.forEach(r => { lastByPerson[r.PersonGUID] = r });

      // --- 4) keep only people whose **last** swipe is IN → currently inside ---
      const inside = Object.values(lastByPerson)
        .filter(r => r.Direction === "InDirection")
        .map(r => ({
          ...r,
          // 5) lookup & trim floor name
          floor: lookupFloor(r.PartitionName2, r.Door, r.Direction)
        }));

      setDetails(inside);
      setLastUpdate(new Date().toLocaleTimeString());
      setLoading(false);
    };

    load();
    const iv = setInterval(load, 1000);
    return () => { active = false; clearInterval(iv); };
  }, [partition]);

  // build a map: floorName → rows[]
  const floorMap = useMemo(() => {
    const m = {};
    // ensure every floor in liveCounts appears
    Object.keys(liveCounts).forEach(f => { m[f] = [] });
    details.forEach(r => {
      const f = r.floor;
      if (!m[f]) m[f] = [];
      m[f].push(r);
    });
    return m;
  }, [details, liveCounts]);

  // filter & sort floors by search + descending headcount
  const term = searchTerm.trim().toLowerCase();
  const displayed = useMemo(() => {
    return Object.entries(floorMap)
      .filter(([floor, emps]) => {
        if (!term) return true;
        if (floor.toLowerCase().includes(term)) return true;
        return emps.some(r =>
          String(r.EmployeeID).toLowerCase().includes(term) ||
          String(r.ObjectName1).toLowerCase().includes(term) ||
          String(r.CardNumber).toLowerCase().includes(term)
        );
      })
      .sort(([a], [b]) =>
        (liveCounts[b] || 0) - (liveCounts[a] || 0)
      );
  }, [floorMap, liveCounts, term]);

  const columns = [
    { field: "EmployeeID", headerName: "Emp ID" },
    { field: "ObjectName1", headerName: "Name" },
    { field: "LocaleMessageTime", headerName: "Swipe Time" },
    { field: "PersonnelType", headerName: "Type" },
    { field: "CardNumber", headerName: "Card" },
    { field: "Door", headerName: "Door" },
  ];

  // format API time string (HH:mm:ss from ISO) into 12h with AM/PM
  const formatApiTime12 = (iso, fallback) => {
    const raw = iso
      ? iso.slice(11, 19) // HH:mm:ss
      : (fallback || '');
    if (!raw) return '';

    // parse HH, mm, ss
    const [hh, mm, ss] = raw.split(':').map(Number);
    const hours12 = ((hh + 11) % 12) + 1; // convert to 1–12
    const ampm = hh >= 12 ? 'PM' : 'AM';
    return `${hours12.toString().padStart(2, '0')}:${mm
      .toString()
      .padStart(2, '0')}:${ss.toString().padStart(2, '0')} ${ampm}`;
  };






  return (
    <>
      <Header />
      <Box sx={{ pt: 1, pb: 1, background: 'rgba(0,0,0,0.6)' }}>
        <Container disableGutters maxWidth={false}>
          <Box display="flex" alignItems="center" mb={2} sx={{ px: 2 }}>
            <Button size="small" onClick={() => navigate(-1)} sx={{ color: '#FFC107' }}>
              ← Back to Overview
            </Button>
          </Box>
          <Box display="flex" alignItems="center" gap={2} mb={2} sx={{ px: 2 }}>
            <Typography variant="h6" sx={{ color: '#FFC107' }}>Floor Details</Typography>
            <Typography variant="body2" sx={{ color: '#FFC107' }}>
              Last updated: {lastUpdate}
            </Typography>
            <TextField
              size="small" placeholder="Search…" value={searchTerm}
              onChange={e => setSearchTerm(e.target.value)}
              sx={{
                '& .MuiInputBase-input': { color: '#FFC107' },
                '& .MuiOutlinedInput-root fieldset': { borderColor: '#FFC107' }
              }}
            />
          </Box>
          {loading
            ? <Box sx={{ px: 2, py: 8 }}><LoadingSpinner /></Box>
            : (
              <>
                <Box display="flex" flexWrap="wrap" width="100%" sx={{ px: 2 }}>
                  {displayed.map(([floor, emps]) => {
                    const showAll = !!term;
                    const preview = showAll
                      ? emps.filter(r =>
                        String(r.EmployeeID).toLowerCase().includes(term) ||
                        String(r.ObjectName1).toLowerCase().includes(term) ||
                        String(r.CardNumber).toLowerCase().includes(term)
                      )
                      : emps.slice(0, 15);

                    return (
                      <Box key={floor} sx={{ width: '50%', p: 2 }}>
                        <Paper sx={{ border: '2px solid #FFC107', p: 2, background: 'rgba(0,0,0,0.4)' }}>
                          <Typography variant="subtitle1" fontWeight={600} sx={{ color: '#FFC107', mb: 1 }}>
                            {floor} (Total {liveCounts[floor] || 0})
                          </Typography>
                          <TableContainer component={Paper} variant="outlined" sx={{ mb: 1, background: 'rgba(0,0,0,0.4)' }}>
                            <Table size="small">
                              <TableHead>
                                <TableRow sx={{ bgcolor: '#000' }}>
                                  {columns.map(c => (
                                    <TableCell key={c.field}
                                      sx={{ color: '#FFC107', fontWeight: 'bold', border: '1px solid #FFC107' }}
                                    >
                                      {c.headerName}
                                    </TableCell>
                                  ))}
                                </TableRow>
                              </TableHead>
                              <TableBody>
                                {preview.map((r, i) => (
                                  <TableRow key={`${r.PersonGUID}-${i}`}
                                    sx={showAll ? { background: 'rgba(255,235,59,0.3)' } : {}}>
                                    <TableCell sx={{ color: '#fff', border: '1px solid #FFC107' }}>{r.EmployeeID}</TableCell>
                                    <TableCell sx={{ color: '#fff', border: '1px solid #FFC107' }}>{r.ObjectName1}</TableCell>


                                    <TableCell sx={{ color: '#fff', border: '1px solid #FFC107' }}>
                                      {formatApiTime12(r.LocaleMessageTime, r.Swipe_Time)}
                                    </TableCell>

                                    <TableCell sx={{ color: '#fff', border: '1px solid #FFC107' }}>{r.PersonnelType}</TableCell>
                                    <TableCell sx={{ color: '#fff', border: '1px solid #FFC107' }}>{r.CardNumber}</TableCell>
                                    <TableCell sx={{ color: '#fff', border: '1px solid #FFC107' }}>{r.Door}</TableCell>
                                  </TableRow>
                                ))}
                              </TableBody>
                            </Table>
                          </TableContainer>
                          <Button size="small" sx={{ color: '#FFC107' }}
                            onClick={() => setExpandedFloor(f => f === floor ? null : floor)}>
                            {expandedFloor === floor ? 'Hide' : 'See more…'}
                          </Button>
                        </Paper>
                      </Box>
                    );
                  })}
                </Box>
                {expandedFloor && (
                  <Box sx={{ px: 2, mt: 2 }}>
                    <Typography variant="h6" sx={{ color: '#FFC107' }} gutterBottom>
                      {expandedFloor} — All Entries
                    </Typography>
                    <DataTable
                      columns={columns}
                      rows={(floorMap[expandedFloor] || []).map(r => ({
                        ...r,
                        LocaleMessageTime: formatApiTime12(r.LocaleMessageTime, r.Swipe_Time)
                      }))}
                    />
                  </Box>
                )}
              </>
            )
          }
        </Container>
      </Box>
      <Footer />
    </>
  );
}






