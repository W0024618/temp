// controllers/liveOccupancyController.js
const { DateTime } = require('luxon');
const { sql, getPool } = require('../config/db');

const doorZoneMap = require('../data/doorZoneMap');
const zoneFloorMap = require('../data/zoneFloorMap');

const ertMembers = require('../data/puneErtMembers.json');

// Track warnings for unknown door keys (same behavior as before)
const warnedKeys = new Set();

// Helper: today's string in Asia/Kolkata
function getTodayString() {
  return DateTime.now().setZone('Asia/Kolkata').toFormat('yyyy-LL-dd');
}

// Normalize zone key (kept same behaviour), but we'll also precompute a normalized map for speed
function normalizeZoneKey(rawDoor, rawDir) {
  let door = String(rawDoor || '').trim();
  door = door.replace(/_[0-9A-F]{2}:[0-9A-F]{2}:[0-9A-F]{2}$/, '');
  door = door.replace(/\s+/g, ' ').toUpperCase();
  const dir = rawDir === 'InDirection' ? 'InDirection' : 'OutDirection';
  return `${door}___${dir}`;
}

function normalizePersonName(raw) {
  let n = String(raw || '').trim();
  if (n.includes(',')) {
    const [last, rest] = n.split(',', 2);
    n = `${rest.trim()} ${last.trim()}`;
  }
  return n.toLowerCase();
}

// Precompute normalized door→zone map for O(1) lookups
const normalizedDoorZoneMap = (() => {
  const m = new Map();
  for (const [k, v] of Object.entries(doorZoneMap)) {
    // assume keys in doorZoneMap may already be normalized, but normalize just in case
    const parts = k.split('___');
    const door = parts[0] || '';
    const dir = parts[1] || '';
    const nk = normalizeZoneKey(door, dir);
    m.set(nk, v);
  }
  return m;
})();

function mapDoorToZone(rawDoor, rawDir) {
  const key = normalizeZoneKey(rawDoor, rawDir);
  const zone = normalizedDoorZoneMap.get(key);
  if (!zone) {
    if (!warnedKeys.has(key)) {
      console.warn('⛔ Unmapped door–direction key:', key);
      warnedKeys.add(key);
    }
    return 'Unknown Zone';
  }
  return zone;
}

/**
 * DATABASE fetch helper:
 * - Fetch only events with MessageUTC > sinceUtc
 * - Returns recordset ordered ascending
 */
async function fetchEventsSince(sinceUtc) {
  const pool = await getPool();
  const req = pool.request();
  req.input('since', sql.DateTime2, sinceUtc);

  const { recordset } = await req.query(`
    WITH CombinedQuery AS (
      SELECT
        t1.MessageUTC,
        t1.MessageUTC AS MessageUTC_Orig,
        t1.ObjectName1,
        CASE
          WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END AS EmployeeID,
        t1.ObjectIdentity1 AS PersonGUID,
        t3.Name AS PersonnelType,
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
          sc.value
        ) AS CardNumber,
        t5a.value AS AdmitCode,
        t5d.value AS Direction,
        t1.ObjectName2 AS Door
      FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLog] t1
      LEFT JOIN [ACVSCore].[Access].[Personnel]     t2 ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN [ACVSCore].[Access].[PersonnelType] t3 ON t2.PersonnelTypeId = t3.ObjectID
      LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5a
        ON t1.XmlGUID = t5a.GUID AND t5a.Name = 'AdmitCode'
      LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5d
        ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
      LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxml] t_xml
        ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, value
        FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred]
        WHERE Name IN ('Card','CHUID')
      ) sc ON t1.XmlGUID = sc.GUID
      WHERE
        t1.MessageType     = 'CardAdmitted'
        AND t1.PartitionName2 = 'APAC.Default'
        AND t1.MessageUTC > @since
    )
    SELECT *
    FROM CombinedQuery
    ORDER BY MessageUTC ASC;
  `);

  return recordset || [];
}

/* ---------------------------
   Incremental in-memory state
   ---------------------------
   - currentPeople: Map<dedupKey, personObject>
   - zoneMap: Map<zone, { total, byPersonnelType: Map, people: [personObject] }>
   - personnelCounts: { employees, contractors }
   - todayVisitors: Set<dedupKey>  (only for current local date)
   - lastMessageUTC: Date (JS Date in UTC) - last MessageUTC processed
*/
const state = {
  currentPeople: new Map(),
  zoneMap: new Map(),
  personnelCounts: { employees: 0, contractors: 0 },
  todayVisitors: new Set(),
  lastMessageUTC: new Date(0), // epoch — will be set on initial load
  cachedOccupancyJson: null, // last serialized occupancy for quick SSE send
  lastTodayString: getTodayString(),
};

/**
 * Utility: determine dedupKey
 */
function dedupKeyFor(evt) {
  return evt.PersonGUID || evt.EmployeeID || evt.CardNumber || evt.ObjectName1 || 'unknown:' + Math.random();
}

/**
 * Process single event and update state incrementally.
 * Assumes evt.MessageUTC is a JS Date (UTC) OR a Date-like convertible.
 * evt.Direction is 'InDirection' or 'OutDirection'
 */
function processEvent(evt) {
  // Convert MessageUTC (JS Date or SQL Date) to luxon for local date/time minimal usage
  const msgUtc = (evt.MessageUTC instanceof Date) ? evt.MessageUTC : new Date(evt.MessageUTC);
  const local = DateTime.fromJSDate(msgUtc, { zone: 'utc' }).setZone('Asia/Kolkata');
  const Dateonly = local.toFormat('yyyy-LL-dd');
  const Swipe_Time = local.toFormat('HH:mm:ss');

  const dedupKey = dedupKeyFor({ ...evt, Dateonly });
  const zoneRaw = mapDoorToZone(evt.Door, evt.Direction);
  if (zoneRaw === 'Unknown Zone') {
    // skip unknown doors entirely
    return;
  }

  const personnelType = evt.PersonnelType || 'Unknown';

  // If it's a different date than current "today", reset todayVisitors (daily rollover)
  const todayStr = getTodayString();
  if (state.lastTodayString !== todayStr) {
    state.todayVisitors = new Set();
    state.lastTodayString = todayStr;
  }

  // Helper to ensure zone entry exists
  function ensureZone(zone) {
    if (!state.zoneMap.has(zone)) {
      state.zoneMap.set(zone, {
        total: 0,
        byPersonnelType: new Map(),
        people: new Map() // Map<dedupKey, person>
      });
    }
    return state.zoneMap.get(zone);
  }

  // If OutDirection for "Out of office", remove person entirely
  if (evt.Direction === 'OutDirection' && zoneRaw.toLowerCase() === 'out of office') {
    // eviction
    const prev = state.currentPeople.get(dedupKey);
    if (prev) {
      // decrement zone counts
      const prevZone = prev.zone;
      const zoneEntry = state.zoneMap.get(prevZone);
      if (zoneEntry && zoneEntry.people.has(dedupKey)) {
        zoneEntry.people.delete(dedupKey);
        zoneEntry.total = Math.max(0, zoneEntry.total - 1);
        const prevPt = prev.PersonnelType || 'Unknown';
        zoneEntry.byPersonnelType.set(prevPt, Math.max(0, (zoneEntry.byPersonnelType.get(prevPt) || 1) - 1));
      }
      // decrement personnelCounts
      if (['Employee', 'Terminated Personnel'].includes(prev.PersonnelType)) {
        state.personnelCounts.employees = Math.max(0, state.personnelCounts.employees - 1);
      } else {
        state.personnelCounts.contractors = Math.max(0, state.personnelCounts.contractors - 1);
      }
      state.currentPeople.delete(dedupKey);
    }
    return;
  }

  // For OutDirection to other zones: treat as "update last seen" (keep them)
  if (evt.Direction === 'OutDirection') {
    // Update last-seen info in place if exists; otherwise add (rare)
    const existing = state.currentPeople.get(dedupKey);
    if (existing) {
      existing.Dateonly = Dateonly;
      existing.Swipe_Time = Swipe_Time;
      existing.zone = zoneRaw;
      existing.door = evt.Door;
      existing.Direction = evt.Direction;

      // If zone changed, move in zoneMap
      if (existing.zone !== zoneRaw) {
        // remove from previous zone
        const prevZoneEntry = state.zoneMap.get(existing.zone);
        if (prevZoneEntry && prevZoneEntry.people.has(dedupKey)) {
          prevZoneEntry.people.delete(dedupKey);
          prevZoneEntry.total = Math.max(0, prevZoneEntry.total - 1);
          const prevPt = existing.PersonnelType || 'Unknown';
          prevZoneEntry.byPersonnelType.set(prevPt, Math.max(0, (prevZoneEntry.byPersonnelType.get(prevPt) || 1) - 1));
        }
        // add to new zone
        const newZoneEntry = ensureZone(zoneRaw);
        newZoneEntry.people.set(dedupKey, existing);
        newZoneEntry.total++;
        newZoneEntry.byPersonnelType.set(personnelType, (newZoneEntry.byPersonnelType.get(personnelType) || 0) + 1);
      }
    } else {
      // treat as an add
      const personObj = {
        Dateonly, Swipe_Time,
        EmployeeID: evt.EmployeeID, ObjectName1: evt.ObjectName1, CardNumber: evt.CardNumber,
        PersonnelType: personnelType, zone: zoneRaw, door: evt.Door, Direction: evt.Direction
      };
      state.currentPeople.set(dedupKey, personObj);
      const zoneEntry = ensureZone(zoneRaw);
      zoneEntry.people.set(dedupKey, personObj);
      zoneEntry.total++;
      zoneEntry.byPersonnelType.set(personnelType, (zoneEntry.byPersonnelType.get(personnelType) || 0) + 1);
      // increment personnelCounts (conservative - treat as contractor unless listed)
      if (['Employee', 'Terminated Personnel'].includes(personnelType)) state.personnelCounts.employees++;
      else state.personnelCounts.contractors++;
    }
    return;
  }

  // InDirection: add/update
  if (evt.Direction === 'InDirection') {
    // Build person object
    const personObj = {
      Dateonly, Swipe_Time,
      EmployeeID: evt.EmployeeID, ObjectName1: evt.ObjectName1, CardNumber: evt.CardNumber,
      PersonnelType: personnelType, zone: zoneRaw, door: evt.Door, Direction: evt.Direction
    };

    const existed = state.currentPeople.get(dedupKey);
    if (existed) {
      // if zone changed, update zone maps
      if (existed.zone !== zoneRaw) {
        const prevZoneEntry = state.zoneMap.get(existed.zone);
        if (prevZoneEntry && prevZoneEntry.people.has(dedupKey)) {
          prevZoneEntry.people.delete(dedupKey);
          prevZoneEntry.total = Math.max(0, prevZoneEntry.total - 1);
          const prevPt = existed.PersonnelType || 'Unknown';
          prevZoneEntry.byPersonnelType.set(prevPt, Math.max(0, (prevZoneEntry.byPersonnelType.get(prevPt) || 1) - 1));
        }
        const newZoneEntry = ensureZone(zoneRaw);
        newZoneEntry.people.set(dedupKey, personObj);
        newZoneEntry.total++;
        newZoneEntry.byPersonnelType.set(personnelType, (newZoneEntry.byPersonnelType.get(personnelType) || 0) + 1);
      } else {
        // same zone: replace person in place
        const zoneEntry = ensureZone(zoneRaw);
        zoneEntry.people.set(dedupKey, personObj);
      }
      // update currentPeople
      state.currentPeople.set(dedupKey, personObj);
    } else {
      // new person
      state.currentPeople.set(dedupKey, personObj);
      const zoneEntry = ensureZone(zoneRaw);
      zoneEntry.people.set(dedupKey, personObj);
      zoneEntry.total++;
      zoneEntry.byPersonnelType.set(personnelType, (zoneEntry.byPersonnelType.get(personnelType) || 0) + 1);

      // increment personnelCounts
      if (['Employee', 'Terminated Personnel'].includes(personnelType)) state.personnelCounts.employees++;
      else state.personnelCounts.contractors++;
    }

    // If the swipe is today, add to todayVisitors set
    if (Dateonly === getTodayString()) {
      state.todayVisitors.add(dedupKey);
    }
    return;
  }

  // Catch-all: if direction unknown -> remove
  const prev = state.currentPeople.get(dedupKey);
  if (prev) {
    // remove from zone maps and counts
    const prevZoneEntry = state.zoneMap.get(prev.zone);
    if (prevZoneEntry && prevZoneEntry.people.has(dedupKey)) {
      prevZoneEntry.people.delete(dedupKey);
      prevZoneEntry.total = Math.max(0, prevZoneEntry.total - 1);
      const prevPt = prev.PersonnelType || 'Unknown';
      prevZoneEntry.byPersonnelType.set(prevPt, Math.max(0, (prevZoneEntry.byPersonnelType.get(prevPt) || 1) - 1));
    }
    if (['Employee', 'Terminated Personnel'].includes(prev.PersonnelType)) {
      state.personnelCounts.employees = Math.max(0, state.personnelCounts.employees - 1);
    } else {
      state.personnelCounts.contractors = Math.max(0, state.personnelCounts.contractors - 1);
    }
    state.currentPeople.delete(dedupKey);
  }
}

/**
 * Compose occupancy snapshot from current state (fast: reads maps, builds lightweight objects)
 */
function composeOccupancySnapshot() {
  // zoneDetails as object
  const zoneDetails = {};
  for (const [zone, entry] of state.zoneMap.entries()) {
    const byType = {};
    for (const [pt, count] of entry.byPersonnelType.entries()) byType[pt] = count;
    zoneDetails[zone] = { total: entry.total, byPersonnelType: byType, employees: Array.from(entry.people.values()) };
  }

  // floor breakdown
  const floorMap = {};
  for (const [zone, data] of Object.entries(zoneDetails)) {
    const floor = zoneFloorMap[zone] || 'Unknown Floor';
    if (!floorMap[floor]) floorMap[floor] = { total: 0, byPersonnelType: {} };
    floorMap[floor].total += data.total;
    for (const [pt, c] of Object.entries(data.byPersonnelType)) {
      floorMap[floor].byPersonnelType[pt] = (floorMap[floor].byPersonnelType[pt] || 0) + c;
    }
  }

  // personnel summary from maintained counts
  const personnelSummary = {
    employees: state.personnelCounts.employees,
    contractors: state.personnelCounts.contractors
  };

  // ertStatus (same logic but uses currentPeople map)
  const ertStatus = Object.fromEntries(
    Object.entries(ertMembers).map(([role, members]) => {
      const list = members.map(m => {
        const rawName = m.name || m.Name;
        const expected = normalizePersonName(rawName);
        const matchEvt = Array.from(state.currentPeople.values()).find(e =>
          normalizePersonName(e.ObjectName1 || '') === expected
        );
        return { ...m, present: !!matchEvt, zone: matchEvt ? matchEvt.zone : null };
      });
      return [role, list];
    })
  );

  // personnel breakdown list (from currentPeople Map)
  const personnelMap = new Map();
  for (const e of state.currentPeople.values()) {
    personnelMap.set(e.PersonnelType, (personnelMap.get(e.PersonnelType) || 0) + 1);
  }
  const personnelBreakdown = Array.from(personnelMap, ([personnelType, count]) => ({ personnelType, count }));

  const snapshot = {
    asOf: new Date().toISOString(),
    summary: Object.entries(zoneDetails).map(([z, d]) => ({ zone: z, count: d.total })),
    zoneBreakdown: Object.entries(zoneDetails).map(([z, d]) => ({ zone: z, ...d.byPersonnelType, total: d.total })),
    floorBreakdown: Object.entries(floorMap).map(([f, d]) => ({ floor: f, ...d.byPersonnelType, total: d.total })),
    details: Object.fromEntries(Object.entries(zoneDetails).map(([z, d]) => [z, d.employees])), // employees lists
    personnelSummary,
    ertStatus,
    personnelBreakdown,
    totalVisitedToday: state.todayVisitors.size,
    visitedToday: { employees: null, contractors: null, total: state.todayVisitors.size }, // employees/contractors not split here
  };

  // compute employees vs contractors in today's visitors by checking person types
  let emp = 0, contractor = 0;
  for (const key of state.todayVisitors) {
    const p = state.currentPeople.get(key);
    if (!p) continue;
    if (['Employee', 'Terminated Personnel'].includes(p.PersonnelType)) emp++;
    else contractor++;
  }
  snapshot.visitedToday.employees = emp;
  snapshot.visitedToday.contractors = contractor;

  // cache the serialized JSON for quick SSE sending when nothing changed
  state.cachedOccupancyJson = JSON.stringify(snapshot);
  return snapshot;
}

/* ---------------------------
   SSE endpoint: incremental polling
   --------------------------- */
exports.getLiveOccupancy = async (req, res) => {
  try {
    await getPool();

    res.writeHead(200, {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive'
    });
    res.write('\n');

    // --- INITIAL LOAD: fetch last 24h once and build initial state ---
    const initialWindowEnd = new Date(); // now UTC
    const initialWindowStart = new Date(initialWindowEnd.getTime() - 24 * 60 * 60 * 1000);
    // We'll set lastMessageUTC to the start-24h marker to fetch everything > start
    state.lastMessageUTC = initialWindowStart;

    // Busy flag to prevent overlapping polls
    let isProcessing = false;

    // Process initial 24h chunk in ascending order
    const initialRows = await (async () => {
      const pool = await getPool();
      const reqDb = pool.request();
      reqDb.input('since', sql.DateTime2, initialWindowStart);
      // reuse the same query shape, but with > @since (which is 24h ago)
      const { recordset } = await reqDb.query(`
        WITH CombinedQuery AS (
          SELECT
            t1.MessageUTC,
            t1.ObjectName1,
            CASE
              WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
              ELSE CAST(t2.Int1 AS NVARCHAR)
            END AS EmployeeID,
            t1.ObjectIdentity1 AS PersonGUID,
            t3.Name AS PersonnelType,
            COALESCE(
              TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
              TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
              sc.value
            ) AS CardNumber,
            t5a.value AS AdmitCode,
            t5d.value AS Direction,
            t1.ObjectName2 AS Door
          FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLog] t1
          LEFT JOIN [ACVSCore].[Access].[Personnel]     t2 ON t1.ObjectIdentity1 = t2.GUID
          LEFT JOIN [ACVSCore].[Access].[PersonnelType] t3 ON t2.PersonnelTypeId = t3.ObjectID
          LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5a
            ON t1.XmlGUID = t5a.GUID AND t5a.Name = 'AdmitCode'
          LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5d
            ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
          LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxml] t_xml
            ON t1.XmlGUID = t_xml.GUID
          LEFT JOIN (
            SELECT GUID, value
            FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred]
            WHERE Name IN ('Card','CHUID')
          ) sc ON t1.XmlGUID = sc.GUID
          WHERE
            t1.MessageType     = 'CardAdmitted'
            AND t1.PartitionName2 = 'APAC.Default'
            AND t1.MessageUTC > @since
        )
        SELECT *
        FROM CombinedQuery
        ORDER BY MessageUTC ASC;
      `);
      return recordset || [];
    })();

    // process initial rows to build state
    for (const r of initialRows) {
      processEvent(r);
      if (r.MessageUTC && (!state.lastMessageUTC || r.MessageUTC > state.lastMessageUTC)) {
        state.lastMessageUTC = r.MessageUTC;
      }
    }

    // Compose initial snapshot
    const initialSnapshot = composeOccupancySnapshot();

    // SSE send helper
    function sendSseObject(obj) {
      const sid = Date.now();
      res.write(`id: ${sid}\n`);
      res.write(`data: ${JSON.stringify(obj)}\n\n`);
      if (typeof res.flush === 'function') res.flush();
    }

    // send initial snapshot immediately
    sendSseObject(initialSnapshot);

    // Polling loop: only fetch MessageUTC > lastMessageUTC
    const pollIntervalMs = 2000; // keep it small if you need near realtime, but no heavy recompute
    let timer = null;
    let closed = false;

    async function pollOnce() {
      if (isProcessing || closed) return;
      isProcessing = true;
      try {
        const sinceUtc = state.lastMessageUTC || new Date(0);
        const rows 
