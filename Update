
// controllers/liveOccupancyController.js
const { DateTime } = require('luxon');
const { sql, getPool } = require('../config/db');

const doorZoneMap = require('../data/doorZoneMap');
const zoneFloorMap = require('../data/zoneFloorMap');

const ertMembers = require('../data/puneErtMembers.json');

// Track warnings for unknown door keys (same behavior as before)
const warnedKeys = new Set();

// Helper: today's string in Asia/Kolkata
function getTodayString() {
  return DateTime.now().setZone('Asia/Kolkata').toFormat('yyyy-LL-dd');
}

// Normalize zone key (kept same behaviour), but we'll also precompute a normalized map for speed
function normalizeZoneKey(rawDoor, rawDir) {
  let door = String(rawDoor || '').trim();
  door = door.replace(/_[0-9A-F]{2}:[0-9A-F]{2}:[0-9A-F]{2}$/, '');
  door = door.replace(/\s+/g, ' ').toUpperCase();
  const dir = rawDir === 'InDirection' ? 'InDirection' : 'OutDirection';
  return `${door}___${dir}`;
}

function normalizePersonName(raw) {
  let n = String(raw || '').trim();
  if (n.includes(',')) {
    const [last, rest] = n.split(',', 2);
    n = `${rest.trim()} ${last.trim()}`;
  }
  return n.toLowerCase();
}

// Precompute normalized door→zone map for O(1) lookups
const normalizedDoorZoneMap = (() => {
  const m = new Map();
  for (const [k, v] of Object.entries(doorZoneMap)) {
    // assume keys in doorZoneMap may already be normalized, but normalize just in case
    const parts = k.split('___');
    const door = parts[0] || '';
    const dir = parts[1] || '';
    const nk = normalizeZoneKey(door, dir);
    m.set(nk, v);
  }
  return m;
})();

function mapDoorToZone(rawDoor, rawDir) {
  const key = normalizeZoneKey(rawDoor, rawDir);
  const zone = normalizedDoorZoneMap.get(key);
  if (!zone) {
    if (!warnedKeys.has(key)) {
      console.warn('⛔ Unmapped door–direction key:', key);
      warnedKeys.add(key);
    }
    return 'Unknown Zone';
  }
  return zone;
}

/**
 * DATABASE fetch helper:
 * - Fetch only events with MessageUTC > sinceUtc
 * - Returns recordset ordered ascending
 */
async function fetchEventsSince(sinceUtc) {
  const pool = await getPool();
  const req = pool.request();
  req.input('since', sql.DateTime2, sinceUtc);

  const { recordset } = await req.query(`
    WITH CombinedQuery AS (
      SELECT
        t1.MessageUTC,
        t1.MessageUTC AS MessageUTC_Orig,
        t1.ObjectName1,
        CASE
          WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END AS EmployeeID,
        t1.ObjectIdentity1 AS PersonGUID,
        t3.Name AS PersonnelType,
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
          sc.value
        ) AS CardNumber,
        t5a.value AS AdmitCode,
        t5d.value AS Direction,
        t1.ObjectName2 AS Door
      FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLog] t1
      LEFT JOIN [ACVSCore].[Access].[Personnel]     t2 ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN [ACVSCore].[Access].[PersonnelType] t3 ON t2.PersonnelTypeId = t3.ObjectID
      LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5a
        ON t1.XmlGUID = t5a.GUID AND t5a.Name = 'AdmitCode'
      LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5d
        ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
      LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxml] t_xml
        ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, value
        FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred]
        WHERE Name IN ('Card','CHUID')
      ) sc ON t1.XmlGUID = sc.GUID
      WHERE
        t1.MessageType     = 'CardAdmitted'
        AND t1.PartitionName2 = 'APAC.Default'
        AND t1.MessageUTC > @since
    )
    SELECT *
    FROM CombinedQuery
    ORDER BY MessageUTC ASC;
  `);

  return recordset || [];
}

/* ---------------------------
   Incremental in-memory state
   ---------------------------
   - currentPeople: Map<dedupKey, personObject>
   - zoneMap: Map<zone, { total, byPersonnelType: Map, people: [personObject] }>
   - personnelCounts: { employees, contractors }
   - todayVisitors: Set<dedupKey>  (only for current local date)
   - lastMessageUTC: Date (JS Date in UTC) - last MessageUTC processed
*/
const state = {
  currentPeople: new Map(),
  zoneMap: new Map(),
  personnelCounts: { employees: 0, contractors: 0 },
  todayVisitors: new Set(),
  lastMessageUTC: new Date(0), // epoch — will be set on initial load
  cachedOccupancyJson: null, // last serialized occupancy for quick SSE send
  lastTodayString: getTodayString(),
};

/**
 * Utility: determine dedupKey
 */
function dedupKeyFor(evt) {
  return evt.PersonGUID || evt.EmployeeID || evt.CardNumber || evt.ObjectName1 || 'unknown:' + Math.random();
}

/**
 * Process single event and update state incrementally.
 * Assumes evt.MessageUTC is a JS Date (UTC) OR a Date-like convertible.
 * evt.Direction is 'InDirection' or 'OutDirection'
 */
function processEvent(evt) {
  // Convert MessageUTC (JS Date or SQL Date) to luxon for local date/time minimal usage
  const msgUtc = (evt.MessageUTC instanceof Date) ? evt.MessageUTC : new Date(evt.MessageUTC);
  const local = DateTime.fromJSDate(msgUtc, { zone: 'utc' }).setZone('Asia/Kolkata');
  const Dateonly = local.toFormat('yyyy-LL-dd');
  const Swipe_Time = local.toFormat('HH:mm:ss');

  const dedupKey = dedupKeyFor({ ...evt, Dateonly });
  const zoneRaw = mapDoorToZone(evt.Door, evt.Direction);
  if (zoneRaw === 'Unknown Zone') {
    // skip unknown doors entirely
    return;
  }

  const personnelType = evt.PersonnelType || 'Unknown';

  // If it's a different date than current "today", reset todayVisitors (daily rollover)
  const todayStr = getTodayString();
  if (state.lastTodayString !== todayStr) {
    state.todayVisitors = new Set();
    state.lastTodayString = todayStr;
  }

  // Helper to ensure zone entry exists
  function ensureZone(zone) {
    if (!state.zoneMap.has(zone)) {
      state.zoneMap.set(zone, {
        total: 0,
        byPersonnelType: new Map(),
        people: new Map() // Map<dedupKey, person>
      });
    }
    return state.zoneMap.get(zone);
  }

  // If OutDirection for "Out of office", remove person entirely
  if (evt.Direction === 'OutDirection' && zoneRaw.toLowerCase() === 'out of office') {
    // eviction
    const prev = state.currentPeople.get(dedupKey);
    if (prev) {
      // decrement zone counts
      const prevZone = prev.zone;
      const zoneEntry = state.zoneMap.get(prevZone);
      if (zoneEntry && zoneEntry.people.has(dedupKey)) {
        zoneEntry.people.delete(dedupKey);
        zoneEntry.total = Math.max(0, zoneEntry.total - 1);
        const prevPt = prev.PersonnelType || 'Unknown';
        zoneEntry.byPersonnelType.set(prevPt, Math.max(0, (zoneEntry.byPersonnelType.get(prevPt) || 1) - 1));
      }
      // decrement personnelCounts
      if (['Employee', 'Terminated Personnel'].includes(prev.PersonnelType)) {
        state.personnelCounts.employees = Math.max(0, state.personnelCounts.employees - 1);
      } else {
        state.personnelCounts.contractors = Math.max(0, state.personnelCounts.contractors - 1);
      }
      state.currentPeople.delete(dedupKey);
    }
    return;
  }

  // For OutDirection to other zones: treat as "update last seen" (keep them)
  if (evt.Direction === 'OutDirection') {
    // Update last-seen info in place if exists; otherwise add (rare)
    const existing = state.currentPeople.get(dedupKey);
    if (existing) {
      existing.Dateonly = Dateonly;
      existing.Swipe_Time = Swipe_Time;
      existing.zone = zoneRaw;
      existing.door = evt.Door;
      existing.Direction = evt.Direction;

      // If zone changed, move in zoneMap
      if (existing.zone !== zoneRaw) {
        // remove from previous zone
        const prevZoneEntry = state.zoneMap.get(existing.zone);
        if (prevZoneEntry && prevZoneEntry.people.has(dedupKey)) {
          prevZoneEntry.people.delete(dedupKey);
          prevZoneEntry.total = Math.max(0, prevZoneEntry.total - 1);
          const prevPt = existing.PersonnelType || 'Unknown';
          prevZoneEntry.byPersonnelType.set(prevPt, Math.max(0, (prevZoneEntry.byPersonnelType.get(prevPt) || 1) - 1));
        }
        // add to new zone
        const newZoneEntry = ensureZone(zoneRaw);
        newZoneEntry.people.set(dedupKey, existing);
        newZoneEntry.total++;
        newZoneEntry.byPersonnelType.set(personnelType, (newZoneEntry.byPersonnelType.get(personnelType) || 0) + 1);
      }
    } else {
      // treat as an add
      const personObj = {
        Dateonly, Swipe_Time,
        EmployeeID: evt.EmployeeID, ObjectName1: evt.ObjectName1, CardNumber: evt.CardNumber,
        PersonnelType: personnelType, zone: zoneRaw, door: evt.Door, Direction: evt.Direction
      };
      state.currentPeople.set(dedupKey, personObj);
      const zoneEntry = ensureZone(zoneRaw);
      zoneEntry.people.set(dedupKey, personObj);
      zoneEntry.total++;
      zoneEntry.byPersonnelType.set(personnelType, (zoneEntry.byPersonnelType.get(personnelType) || 0) + 1);
      // increment personnelCounts (conservative - treat as contractor unless listed)
      if (['Employee', 'Terminated Personnel'].includes(personnelType)) state.personnelCounts.employees++;
      else state.personnelCounts.contractors++;
    }
    return;
  }

  // InDirection: add/update
  if (evt.Direction === 'InDirection') {
    // Build person object
    const personObj = {
      Dateonly, Swipe_Time,
      EmployeeID: evt.EmployeeID, ObjectName1: evt.ObjectName1, CardNumber: evt.CardNumber,
      PersonnelType: personnelType, zone: zoneRaw, door: evt.Door, Direction: evt.Direction
    };

    const existed = state.currentPeople.get(dedupKey);
    if (existed) {
      // if zone changed, update zone maps
      if (existed.zone !== zoneRaw) {
        const prevZoneEntry = state.zoneMap.get(existed.zone);
        if (prevZoneEntry && prevZoneEntry.people.has(dedupKey)) {
          prevZoneEntry.people.delete(dedupKey);
          prevZoneEntry.total = Math.max(0, prevZoneEntry.total - 1);
          const prevPt = existed.PersonnelType || 'Unknown';
          prevZoneEntry.byPersonnelType.set(prevPt, Math.max(0, (prevZoneEntry.byPersonnelType.get(prevPt) || 1) - 1));
        }
        const newZoneEntry = ensureZone(zoneRaw);
        newZoneEntry.people.set(dedupKey, personObj);
        newZoneEntry.total++;
        newZoneEntry.byPersonnelType.set(personnelType, (newZoneEntry.byPersonnelType.get(personnelType) || 0) + 1);
      } else {
        // same zone: replace person in place
        const zoneEntry = ensureZone(zoneRaw);
        zoneEntry.people.set(dedupKey, personObj);
      }
      // update currentPeople
      state.currentPeople.set(dedupKey, personObj);
    } else {
      // new person
      state.currentPeople.set(dedupKey, personObj);
      const zoneEntry = ensureZone(zoneRaw);
      zoneEntry.people.set(dedupKey, personObj);
      zoneEntry.total++;
      zoneEntry.byPersonnelType.set(personnelType, (zoneEntry.byPersonnelType.get(personnelType) || 0) + 1);

      // increment personnelCounts
      if (['Employee', 'Terminated Personnel'].includes(personnelType)) state.personnelCounts.employees++;
      else state.personnelCounts.contractors++;
    }

    // If the swipe is today, add to todayVisitors set
    if (Dateonly === getTodayString()) {
      state.todayVisitors.add(dedupKey);
    }
    return;
  }

  // Catch-all: if direction unknown -> remove
  const prev = state.currentPeople.get(dedupKey);
  if (prev) {
    // remove from zone maps and counts
    const prevZoneEntry = state.zoneMap.get(prev.zone);
    if (prevZoneEntry && prevZoneEntry.people.has(dedupKey)) {
      prevZoneEntry.people.delete(dedupKey);
      prevZoneEntry.total = Math.max(0, prevZoneEntry.total - 1);
      const prevPt = prev.PersonnelType || 'Unknown';
      prevZoneEntry.byPersonnelType.set(prevPt, Math.max(0, (prevZoneEntry.byPersonnelType.get(prevPt) || 1) - 1));
    }
    if (['Employee', 'Terminated Personnel'].includes(prev.PersonnelType)) {
      state.personnelCounts.employees = Math.max(0, state.personnelCounts.employees - 1);
    } else {
      state.personnelCounts.contractors = Math.max(0, state.personnelCounts.contractors - 1);
    }
    state.currentPeople.delete(dedupKey);
  }
}

/**
 * Compose occupancy snapshot from current state (fast: reads maps, builds lightweight objects)
 */
function composeOccupancySnapshot() {
  // zoneDetails as object
  const zoneDetails = {};
  for (const [zone, entry] of state.zoneMap.entries()) {
    const byType = {};
    for (const [pt, count] of entry.byPersonnelType.entries()) byType[pt] = count;
    zoneDetails[zone] = { total: entry.total, byPersonnelType: byType, employees: Array.from(entry.people.values()) };
  }

  // floor breakdown
  const floorMap = {};
  for (const [zone, data] of Object.entries(zoneDetails)) {
    const floor = zoneFloorMap[zone] || 'Unknown Floor';
    if (!floorMap[floor]) floorMap[floor] = { total: 0, byPersonnelType: {} };
    floorMap[floor].total += data.total;
    for (const [pt, c] of Object.entries(data.byPersonnelType)) {
      floorMap[floor].byPersonnelType[pt] = (floorMap[floor].byPersonnelType[pt] || 0) + c;
    }
  }

  // personnel summary from maintained counts
  const personnelSummary = {
    employees: state.personnelCounts.employees,
    contractors: state.personnelCounts.contractors
  };

  // ertStatus (same logic but uses currentPeople map)
  const ertStatus = Object.fromEntries(
    Object.entries(ertMembers).map(([role, members]) => {
      const list = members.map(m => {
        const rawName = m.name || m.Name;
        const expected = normalizePersonName(rawName);
        const matchEvt = Array.from(state.currentPeople.values()).find(e =>
          normalizePersonName(e.ObjectName1 || '') === expected
        );
        return { ...m, present: !!matchEvt, zone: matchEvt ? matchEvt.zone : null };
      });
      return [role, list];
    })
  );

  // personnel breakdown list (from currentPeople Map)
  const personnelMap = new Map();
  for (const e of state.currentPeople.values()) {
    personnelMap.set(e.PersonnelType, (personnelMap.get(e.PersonnelType) || 0) + 1);
  }
  const personnelBreakdown = Array.from(personnelMap, ([personnelType, count]) => ({ personnelType, count }));

  const snapshot = {
    asOf: new Date().toISOString(),
    summary: Object.entries(zoneDetails).map(([z, d]) => ({ zone: z, count: d.total })),
    zoneBreakdown: Object.entries(zoneDetails).map(([z, d]) => ({ zone: z, ...d.byPersonnelType, total: d.total })),
    floorBreakdown: Object.entries(floorMap).map(([f, d]) => ({ floor: f, ...d.byPersonnelType, total: d.total })),
    details: Object.fromEntries(Object.entries(zoneDetails).map(([z, d]) => [z, d.employees])), // employees lists
    personnelSummary,
    ertStatus,
    personnelBreakdown,
    totalVisitedToday: state.todayVisitors.size,
    visitedToday: { employees: null, contractors: null, total: state.todayVisitors.size }, // employees/contractors not split here
  };

  // compute employees vs contractors in today's visitors by checking person types
  let emp = 0, contractor = 0;
  for (const key of state.todayVisitors) {
    const p = state.currentPeople.get(key);
    if (!p) continue;
    if (['Employee', 'Terminated Personnel'].includes(p.PersonnelType)) emp++;
    else contractor++;
  }
  snapshot.visitedToday.employees = emp;
  snapshot.visitedToday.contractors = contractor;

  // cache the serialized JSON for quick SSE sending when nothing changed
  state.cachedOccupancyJson = JSON.stringify(snapshot);
  return snapshot;
}

/* ---------------------------
   SSE endpoint: incremental polling
   --------------------------- */
exports.getLiveOccupancy = async (req, res) => {
  try {
    await getPool();

    res.writeHead(200, {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive'
    });
    res.write('\n');

    // --- INITIAL LOAD: fetch last 24h once and build initial state ---
    const initialWindowEnd = new Date(); // now UTC
    const initialWindowStart = new Date(initialWindowEnd.getTime() - 24 * 60 * 60 * 1000);
    // We'll set lastMessageUTC to the start-24h marker to fetch everything > start
    state.lastMessageUTC = initialWindowStart;

    // Busy flag to prevent overlapping polls
    let isProcessing = false;

    // Process initial 24h chunk in ascending order
    const initialRows = await (async () => {
      const pool = await getPool();
      const reqDb = pool.request();
      reqDb.input('since', sql.DateTime2, initialWindowStart);
      // reuse the same query shape, but with > @since (which is 24h ago)
      const { recordset } = await reqDb.query(`
        WITH CombinedQuery AS (
          SELECT
            t1.MessageUTC,
            t1.ObjectName1,
            CASE
              WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
              ELSE CAST(t2.Int1 AS NVARCHAR)
            END AS EmployeeID,
            t1.ObjectIdentity1 AS PersonGUID,
            t3.Name AS PersonnelType,
            COALESCE(
              TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
              TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
              sc.value
            ) AS CardNumber,
            t5a.value AS AdmitCode,
            t5d.value AS Direction,
            t1.ObjectName2 AS Door
          FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLog] t1
          LEFT JOIN [ACVSCore].[Access].[Personnel]     t2 ON t1.ObjectIdentity1 = t2.GUID
          LEFT JOIN [ACVSCore].[Access].[PersonnelType] t3 ON t2.PersonnelTypeId = t3.ObjectID
          LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5a
            ON t1.XmlGUID = t5a.GUID AND t5a.Name = 'AdmitCode'
          LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5d
            ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
          LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxml] t_xml
            ON t1.XmlGUID = t_xml.GUID
          LEFT JOIN (
            SELECT GUID, value
            FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred]
            WHERE Name IN ('Card','CHUID')
          ) sc ON t1.XmlGUID = sc.GUID
          WHERE
            t1.MessageType     = 'CardAdmitted'
            AND t1.PartitionName2 = 'APAC.Default'
            AND t1.MessageUTC > @since
        )
        SELECT *
        FROM CombinedQuery
        ORDER BY MessageUTC ASC;
      `);
      return recordset || [];
    })();

    // process initial rows to build state
    for (const r of initialRows) {
      processEvent(r);
      if (r.MessageUTC && (!state.lastMessageUTC || r.MessageUTC > state.lastMessageUTC)) {
        state.lastMessageUTC = r.MessageUTC;
      }
    }

    // Compose initial snapshot
    const initialSnapshot = composeOccupancySnapshot();

    // SSE send helper
    function sendSseObject(obj) {
      const sid = Date.now();
      res.write(`id: ${sid}\n`);
      res.write(`data: ${JSON.stringify(obj)}\n\n`);
      if (typeof res.flush === 'function') res.flush();
    }

    // send initial snapshot immediately
    sendSseObject(initialSnapshot);

    // Polling loop: only fetch MessageUTC > lastMessageUTC
    const pollIntervalMs = 2000; // keep it small if you need near realtime, but no heavy recompute
    let timer = null;
    let closed = false;

    async function pollOnce() {
      if (isProcessing || closed) return;
      isProcessing = true;
      try {
        const sinceUtc = state.lastMessageUTC || new Date(0);
        const rows = await fetchEventsSince(sinceUtc);
        if (rows.length === 0) {
          // nothing new -> re-send cached snapshot minimal payload (cheap)
          if (state.cachedOccupancyJson) {
            const sid = Date.now();
            res.write(`id: ${sid}\n`);
            res.write(`data: ${state.cachedOccupancyJson}\n\n`);
            if (typeof res.flush === 'function') res.flush();
          }
          isProcessing = false;
          return;
        }

        // process new rows in order
        for (const r of rows) {
          processEvent(r);

          // track last MessageUTC handled (assumes db rows are ordered ascending)
          if (r.MessageUTC && (!state.lastMessageUTC || r.MessageUTC > state.lastMessageUTC)) {
            state.lastMessageUTC = r.MessageUTC;
          }
        }

        // compose new snapshot only once after processing the batch
        const snap = composeOccupancySnapshot();
        sendSseObject(snap);
      } catch (err) {
        console.error('SSE polling error:', err);
        // If error, try to send a minimal error payload (do not close connection)
        const sid = Date.now();
        const errObj = { error: 'backend_error', message: String(err) };
        res.write(`id: ${sid}\n`);
        res.write(`data: ${JSON.stringify(errObj)}\n\n`);
        if (typeof res.flush === 'function') res.flush();
      } finally {
        isProcessing = false;
      }
    }

    // Start periodic poll
    timer = setInterval(pollOnce, pollIntervalMs);

    req.on('close', () => {
      closed = true;
      if (timer) clearInterval(timer);
    });

  } catch (err) {
    console.error('Live occupancy SSE error:', err);
    if (!res.headersSent) {
      res.status(500).json({ error: 'Internal Server Error' });
    }
  }
};

/* ---------------------------
   Snapshot endpoints (left mostly intact, a few micro-optimisations)
   --------------------------- */

// GET /api/occupancy-at-time-pune?date=YYYY-MM-DD&time=HH:MM[:SS]
exports.getPuneSnapshotAtDateTime = async (req, res) => {
  try {
    const { date, time } = req.query;
    if (!date || !time) return res.status(400).json({ error: 'missing query params: expected ?date=YYYY-MM-DD&time=HH:MM[:SS]' });

    const dateMatch = /^(\d{4})-(\d{2})-(\d{2})$/.exec(date);
    if (!dateMatch) return res.status(400).json({ error: 'invalid "date" format; expected YYYY-MM-DD' });

    const timeMatch = /^([0-1]\d|2[0-3]):([0-5]\d)(?::([0-5]\d))?$/.exec(time);
    if (!timeMatch) return res.status(400).json({ error: 'invalid "time" format; expected HH:MM or HH:MM:SS' });

    const year = Number(dateMatch[1]);
    const month = Number(dateMatch[2]);
    const day = Number(dateMatch[3]);
    const hour = Number(timeMatch[1]);
    const minute = Number(timeMatch[2]);
    const second = timeMatch[3] ? Number(timeMatch[3]) : 0;

    const atDt = DateTime.fromObject({ year, month, day, hour, minute, second, millisecond: 0 }, { zone: 'Asia/Kolkata' });
    if (!atDt.isValid) return res.status(400).json({ error: 'invalid date+time combination' });

    const untilUtc = atDt.setZone('utc').toJSDate();

    const pool = await getPool();
    const reqDb = pool.request();
    reqDb.input('until', sql.DateTime2, untilUtc);

    const { recordset } = await reqDb.query(`
      WITH CombinedQuery AS (
        SELECT
          t1.MessageUTC,
          t1.ObjectName1,
          CASE
            WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
            ELSE CAST(t2.Int1 AS NVARCHAR)
          END AS EmployeeID,
          t1.ObjectIdentity1 AS PersonGUID,
          t3.Name AS PersonnelType,
          COALESCE(
            TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
            TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
            sc.value
          ) AS CardNumber,
          t5a.value AS AdmitCode,
          t5d.value AS Direction,
          t1.ObjectName2 AS Door
        FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLog] t1
        LEFT JOIN [ACVSCore].[Access].[Personnel]     t2 ON t1.ObjectIdentity1 = t2.GUID
        LEFT JOIN [ACVSCore].[Access].[PersonnelType] t3 ON t2.PersonnelTypeId = t3.ObjectID
        LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5a
          ON t1.XmlGUID = t5a.GUID AND t5a.Name = 'AdmitCode'
        LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5d
          ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
        LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxml] t_xml
          ON t1.XmlGUID = t_xml.GUID
        LEFT JOIN (
          SELECT GUID, value
          FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred]
          WHERE Name IN ('Card','CHUID')
        ) sc ON t1.XmlGUID = sc.GUID
        WHERE
          t1.MessageType = 'CardAdmitted'
          AND t1.PartitionName2 = 'APAC.Default'
          AND t1.MessageUTC <= @until
          AND DATEADD(HOUR, -24, @until) < t1.MessageUTC
      )
      SELECT *
      FROM CombinedQuery
      ORDER BY MessageUTC ASC;
    `);

    const events = recordset.map(e => {
      const local = DateTime.fromJSDate(e.MessageUTC, { zone: 'utc' }).setZone('Asia/Kolkata');
      return {
        ...e,
        MessageUTC: e.MessageUTC,
        LocaleMessageTime: local.toISO(),
        Dateonly: local.toFormat('yyyy-LL-dd'),
        Swipe_Time: local.toFormat('HH:mm:ss')
      };
    });

    const targetDate = atDt.toFormat('yyyy-LL-dd');
    const filtered = events.filter(e => e.Dateonly === targetDate);

    // Reuse the original buildVisitedToday style but lightweight here:
    const occupancy = await (async () => {
      // reuse a local buildOccupancy-like computation but only on the filtered array
      // We'll reuse the earlier process: create a fresh map of uniquePeople and current for this slice and then transform
      const current = {};
      const uniquePeople = new Map();

      for (const evt of filtered) {
        const { EmployeeID, PersonGUID, ObjectName1, PersonnelType, CardNumber, Dateonly, Swipe_Time, Direction, Door } = evt;
        const dedupKey = PersonGUID || EmployeeID || CardNumber || ObjectName1;
        const zoneRaw = mapDoorToZone(Door, Direction);
        if (zoneRaw === 'Unknown Zone') continue;

        if (Direction === 'OutDirection') {
          if (zoneRaw.toLowerCase() === 'out of office') {
            uniquePeople.delete(dedupKey);
            delete current[dedupKey];
          } else {
            uniquePeople.set(dedupKey, PersonnelType);
            current[dedupKey] = { Dateonly, Swipe_Time, EmployeeID, ObjectName1, CardNumber, PersonnelType, zone: zoneRaw, door: Door, Direction };
          }
          continue;
        }
        if (Direction === 'InDirection') {
          uniquePeople.set(dedupKey, PersonnelType);
          current[dedupKey] = { Dateonly, Swipe_Time, EmployeeID, ObjectName1, CardNumber, PersonnelType, zone: zoneRaw, door: Door, Direction };
          continue;
        }
        uniquePeople.delete(dedupKey);
        delete current[dedupKey];
      }

      // build simple zone→people map
      const zoneMap = {};
      for (const emp of Object.values(current)) {
        const zKey = emp.zone.toLowerCase();
        if (zKey === 'out of office') continue;
        zoneMap[emp.zone] = zoneMap[emp.zone] || [];
        zoneMap[emp.zone].push(emp);
      }
      const zoneDetails = Object.fromEntries(Object.entries(zoneMap).map(([zone, emps]) => {
        const byType = emps.reduce((acc, e) => { acc[e.PersonnelType] = (acc[e.PersonnelType] || 0) + 1; return acc; }, {});
        return [zone, { total: emps.length, byPersonnelType: byType, employees: emps }];
      }));

      const floorMapLocal = {};
      for (const [zone, data] of Object.entries(zoneDetails)) {
        const floor = zoneFloorMap[zone] || 'Unknown Floor';
        floorMapLocal[floor] = floorMapLocal[floor] || { total: 0, byPersonnelType: {} };
        floorMapLocal[floor].total += data.total;
        for (const [pt, c] of Object.entries(data.byPersonnelType)) {
          floorMapLocal[floor].byPersonnelType[pt] = (floorMapLocal[floor].byPersonnelType[pt] || 0) + c;
        }
      }

      const employeeCount = Array.from(uniquePeople.values()).reduce((acc, pt) => acc + (['Employee', 'Terminated Personnel'].includes(pt) ? 1 : 0), 0);
      const contractorCount = Array.from(uniquePeople.values()).length - employeeCount;

      const personnelBreakdown = (() => {
        const map = new Map();
        for (const pt of uniquePeople.values()) map.set(pt, (map.get(pt) || 0) + 1);
        return Array.from(map, ([personnelType, count]) => ({ personnelType, count }));
      })();

      return {
        asOf: new Date().toISOString(),
        summary: Object.entries(zoneDetails).map(([z, d]) => ({ zone: z, count: d.total })),
        zoneBreakdown: Object.entries(zoneDetails).map(([z, d]) => ({ zone: z, ...d.byPersonnelType, total: d.total })),
        floorBreakdown: Object.entries(floorMapLocal).map(([f, d]) => ({ floor: f, ...d.byPersonnelType, total: d.total })),
        details: zoneMap,
        personnelSummary: { employees: employeeCount, contractors: contractorCount },
        personnelBreakdown,
      };
    })();

    // visited today aligned to atDt
    const visitedStats = (function buildVisitedTodayLocal(allEvents, asOf) {
      let today;
      if (asOf) {
        if (typeof asOf === 'string') today = asOf;
        else if (asOf instanceof Date) today = DateTime.fromJSDate(asOf, { zone: 'Asia/Kolkata' }).toFormat('yyyy-LL-dd');
        else if (asOf && typeof asOf.toFormat === 'function') today = asOf.setZone('Asia/Kolkata').toFormat('yyyy-LL-dd');
        else today = DateTime.now().setZone('Asia/Kolkata').toFormat('yyyy-LL-dd');
      } else {
        today = DateTime.now().setZone('Asia/Kolkata').toFormat('yyyy-LL-dd');
      }

      const todayIns = allEvents.filter(evt => evt.Direction === 'InDirection' && evt.Dateonly === today);
      const dedup = new Map();
      for (const e of todayIns) {
        const key = e.PersonGUID;
        const prev = dedup.get(key);
        if (!prev || e.LocaleMessageTime > prev.LocaleMessageTime) dedup.set(key, e);
      }
      const finalList = Array.from(dedup.values());
      const employees = finalList.filter(e => !['Contractor','Terminated Contractor','Temp Badge','Visitor','Property Management'].includes(e.PersonnelType)).length;
      const contractors = finalList.length - employees;
      return { employees, contractors, total: finalList.length };
    })(filtered, atDt);

    occupancy.asOfLocal = atDt.toISO();
    occupancy.asOfUTC = `${date}T${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}:${String(second).padStart(2, '0')}Z`;

    occupancy.totalVisitedToday = visitedStats.total;
    occupancy.visitedToday = visitedStats;

    return res.json(occupancy);
  } catch (err) {
    console.error('getPuneSnapshotAtDateTime error:', err);
    return res.status(500).json({ error: 'Internal Server Error' });
  }
};

// GET /api/monthly-summary?month=YYYY-MM
exports.getMonthlySummary = async (req, res) => {
  try {
    const { month } = req.query;
    if (!month || !/^\d{4}-\d{2}$/.test(month)) return res.status(400).json({ error: 'invalid "month" format; expected YYYY-MM' });

    const [year, monthNum] = month.split('-').map(Number);
    const start = DateTime.fromObject({ year, month: monthNum, day: 1 }, { zone: 'Asia/Kolkata' });
    const end = start.endOf('month');

    const startUtc = start.setZone('utc').toJSDate();
    const endUtc = end.setZone('utc').toJSDate();

    const pool = await getPool();
    const reqDb = pool.request();
    reqDb.input('start', sql.DateTime2, startUtc);
    reqDb.input('end', sql.DateTime2, endUtc);

    const { recordset } = await reqDb.query(`
      SELECT
        t1.MessageUTC,
        t1.ObjectName1,
        CASE
          WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END AS EmployeeID,
        t1.ObjectIdentity1 AS PersonGUID,
        t3.Name AS PersonnelType,
        t5d.value AS Direction,
        t1.ObjectName2 AS Door
      FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLog] t1
      LEFT JOIN [ACVSCore].[Access].[Personnel]     t2 ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN [ACVSCore].[Access].[PersonnelType] t3 ON t2.PersonnelTypeId = t3.ObjectID
      LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5d
        ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
      WHERE
        t1.MessageType = 'CardAdmitted'
        AND t1.PartitionName2 = 'APAC.Default'
        AND t1.MessageUTC BETWEEN @start AND @end
      ORDER BY t1.MessageUTC ASC;
    `);

    const events = recordset.map(e => {
      const local = DateTime.fromJSDate(e.MessageUTC, { zone: 'utc' }).setZone('Asia/Kolkata');
      return {
        ...e,
        LocaleMessageTime: local.toJSDate(),
        Dateonly: local.toFormat('yyyy-LL-dd'),
        Swipe_Time: local.toFormat('HH:mm:ss'),
      };
    });

    // get all dates in month
    const allDates = [];
    let cursor = start;
    while (cursor <= end) {
      allDates.push(cursor.toFormat('yyyy-LL-dd'));
      cursor = cursor.plus({ days: 1 });
    }

    const byDay = new Map();
    for (const evt of events) {
      if (!byDay.has(evt.Dateonly)) byDay.set(evt.Dateonly, []);
      byDay.get(evt.Dateonly).push(evt);
    }

    const dailySummaries = [];
    const peakOccupancy = [];
    const visitCounter = new Map();
    const presenceByPerson = new Map();

    for (const [dateKey, dayEvents] of byDay.entries()) {
      const uniquePeople = new Set(dayEvents.map(e => e.PersonGUID));
      dailySummaries.push({ date: dateKey, total: uniquePeople.size });

      let currentCount = 0, maxCount = 0;
      for (const e of dayEvents) {
        if (e.Direction === 'InDirection') currentCount++;
        else if (e.Direction === 'OutDirection') currentCount = Math.max(0, currentCount - 1);
        if (currentCount > maxCount) maxCount = currentCount;
      }
      peakOccupancy.push({ date: dateKey, peak: maxCount });

      for (const e of dayEvents) {
        if (e.Direction === 'InDirection') {
          const key = e.PersonGUID || e.EmployeeID || e.ObjectName1;
          if (!visitCounter.has(key)) visitCounter.set(key, { count: 0, employeeId: e.EmployeeID, name: e.ObjectName1, personnelType: e.PersonnelType });
          visitCounter.get(key).count++;

          if (!presenceByPerson.has(key)) presenceByPerson.set(key, { employeeId: e.EmployeeID, name: e.ObjectName1, personnelType: e.PersonnelType, days: new Set() });
          presenceByPerson.get(key).days.add(dateKey);
        }
      }
    }

    const avgDailyHeadcount = dailySummaries.reduce((s, d) => s + d.total, 0) / (dailySummaries.length || 1);
    const top10 = Array.from(visitCounter.values()).sort((a, b) => b.count - a.count).slice(0, 10).map(v => ({
      employeeId: v.employeeId, name: v.name, personnelType: v.personnelType, visits: v.count
    }));

    const attendanceSheet = Array.from(presenceByPerson.values()).map(p => {
      const daily = {}; let presentCount = 0;
      for (const d of allDates) {
        if (p.days.has(d)) { daily[d] = "P"; presentCount++; } else daily[d] = "A";
      }
      return {
        employeeId: p.employeeId, name: p.name, personnelType: p.personnelType,
        ...daily, daysPresent: presentCount, daysAbsent: allDates.length - presentCount,
        attendancePercent: ((presentCount / allDates.length) * 100).toFixed(1) + "%"
      };
    });

    return res.json({
      month,
      avgDailyHeadcount: Math.round(avgDailyHeadcount),
      peakOccupancy,
      top10Visitors: top10,
      attendanceSheet
    });
  } catch (err) {
    console.error('getMonthlySummary error:', err);
    return res.status(500).json({ error: 'Internal Server Error' });
  }
};
