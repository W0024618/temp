C:\Users\W0024618\Desktop\apac-occupancy-frontend\src\pages\History.jsx





// src/pages/History.jsx — APAC Edition

import React, { useEffect, useState, useMemo } from 'react';
import { useParams } from 'react-router-dom';
import {
  Container,
  Box,
  Button,
  Typography,
  Table,
  TableHead,
  TableBody,
  TableRow,
  TableCell,
  Paper,
  TextField,
  TableContainer
} from '@mui/material';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { LocalizationProvider, DatePicker } from '@mui/x-date-pickers';
import { format } from 'date-fns';


import ExcelJS from 'exceljs';
import { saveAs } from 'file-saver';

import Header from '../components/Header';
import Footer from '../components/Footer';
import LoadingSpinner from '../components/LoadingSpinner';
import { fetchHistory } from '../api/occupancy.service';



















C:\Users\W0024618\Desktop\apac-occupancy-frontend\src\pages\PartitionDetailDetails.jsx



// src/pages/PartitionDetailDetails.jsx

import React, { useEffect, useState, useMemo } from "react";
import {
  Container, Box, Typography, Button, TextField,
  Paper, TableContainer, Table, TableHead, TableRow, TableCell, TableBody
} from "@mui/material";
import { useParams, useNavigate } from "react-router-dom";

import Header from "../components/Header";
import Footer from "../components/Footer";
import LoadingSpinner from "../components/LoadingSpinner";
import DataTable from "../components/DataTable";
import ExcelJS from 'exceljs';
import { fetchLiveSummary } from "../api/occupancy.service";
import { lookupFloor } from "../utils/floorLookup";



import { saveAs } from 'file-saver';



export default function PartitionDetailDetails() {
  const { partition } = useParams();
  const navigate = useNavigate();

  const [details, setDetails] = useState([]);
  const [liveCounts, setLiveCounts] = useState({});
  const [loading, setLoading] = useState(true);
  const [lastUpdate, setLastUpdate] = useState("");
  const [search, setSearchTerm] = useState("");
  const [expandedFloor, setExpandedFloor] = useState(null);


  // Helper: format API ISO (UTC) to "hh:mm:ss AM/PM"
  const formatApiDateTime = iso => {
    if (!iso) return "";
    const d = new Date(iso);
    if (isNaN(d)) return iso;

    const hours24 = d.getUTCHours();
    const minutes = String(d.getUTCMinutes()).padStart(2, "0");
    const seconds = String(d.getUTCSeconds()).padStart(2, "0");

    const ampm = hours24 >= 12 ? "PM" : "AM";
    let hour12 = hours24 % 12;
    if (hour12 === 0) hour12 = 12;
    const hourStr = String(hour12).padStart(2, "0");

    return `${hourStr}:${minutes}:${seconds} ${ampm}`;
  };



  // 2) add this export handler inside the component (place it after formatApiDateTime and before the return)
  // const handleExportFloor = (floor, emps) => {
  //   if (!emps || emps.length === 0) return;

  //   // build rows: header + data
  //   const rows = [
  //     ['Emp ID', 'Name', 'Swipe Time', 'Type', 'Company', 'Direction','Card', 'Door'],
  //     ...emps.map(r => [
  //       r.EmployeeID ?? '',
  //       r.ObjectName1 ?? '',
  //       formatApiDateTime(r.LocaleMessageTime),
  //       r.PersonnelType ?? '',
  //       r.CompanyName ?? '',
  //       r.Direction ?? '',
  //       r.CardNumber ?? '',
  //       r.Door ?? ''
  //     ])
  //   ];

  //   // convert to sheet & workbook
  //   const ws = XLSX.utils.aoa_to_sheet(rows);
  //   const wb = XLSX.utils.book_new();
  //   XLSX.utils.book_append_sheet(wb, ws, 'FloorExport');

  //   // filename safe floor name + timestamp
  //   const safeFloor = floor.replace(/[^a-z0-9\-_]/gi, '_').slice(0, 80);
  //   const ts = new Date().toISOString().slice(0, 19).replace(/[:T]/g, '-');
  //   const filename = `${partition || 'partition'}_${safeFloor}_${ts}.xlsx`;

  //   const buf = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
  //   saveAs(new Blob([buf]), filename);
  // };






  const handleExportFloor = async (floor, emps) => {
  if (!emps || emps.length === 0) return;

  const workbook = new ExcelJS.Workbook();
  const sheet = workbook.addWorksheet("FloorExport");

  // --- Header row ---
  const headers = [
    "Emp ID",
    "Name",
    "Swipe Time",
    "Type",
    "Company",
    "Direction",
    "Card",
    "Door"
  ];
  const headerRow = sheet.addRow(headers);
  headerRow.eachCell(cell => {
    cell.font = { bold: true, color: { argb: "FFFFFFFF" } };
    cell.fill = {
      type: "pattern",
      pattern: "solid",
      fgColor: { argb: "8b8c8f" } // Yellow
    };
    cell.alignment = { horizontal: "center", vertical: "middle" };
    cell.border = {
      top: { style: "thin" },
      left: { style: "thin" },
      bottom: { style: "thin" },
      right: { style: "thin" }
    };
  });

  // --- Data rows ---
  emps.forEach(r => {
    const row = sheet.addRow([
      r.EmployeeID ?? "",
      r.ObjectName1 ?? "",
      formatApiDateTime(r.LocaleMessageTime),
      r.PersonnelType ?? "",
      r.CompanyName ?? "",
      r.Direction ?? "",
      r.CardNumber ?? "",
      r.Door ?? ""
    ]);

    row.eachCell(cell => {
      cell.border = {
        top: { style: "thin" },
        left: { style: "thin" },
        bottom: { style: "thin" },
        right: { style: "thin" }
      };
    });
  });

  // --- Auto column width ---
  sheet.columns.forEach(col => {
    let maxLen = 7;
    col.eachCell({ includeEmpty: true }, c => {
      maxLen = Math.max(maxLen, (c.value ? c.value.toString().length : 0) + 2);
    });
    col.width = Math.min(Math.max(maxLen, 17), 40);
  });

  // --- Filename (safe floor name + timestamp) ---
  const safeFloor = floor.replace(/[^a-z0-9\-_]/gi, "_").slice(0, 80);
  const ts = new Date().toISOString().slice(0, 19).replace(/[:T]/g, "-");
  const filename = `${safeFloor}_${ts}.xlsx`;

  // --- Save file ---
  const buf = await workbook.xlsx.writeBuffer();
  saveAs(new Blob([buf]), filename);
};



  // 1) Filter the raw details → keep only In/Out for this partition,
  //    map to include floor, then drop any that resolve to "Unmapped"
  const filterAndMap = json =>
    json.details
      .filter(r =>
        r.PartitionName2 === partition &&
        (r.Direction === "InDirection" || r.Direction === "OutDirection")
      )
      .map(r => {
        const floor = lookupFloor(r.PartitionName2, r.Door, r.Direction);
        return { ...r, floor };
      })
      .filter(r => r.floor !== "Unmapped");  // remove any Out-of-office / unmapped

  // initial load
  useEffect(() => {
    let active = true;
    fetchLiveSummary().then(json => {
      if (!active) return;
      setLiveCounts(json.realtime[partition]?.floors || {});
      setDetails(filterAndMap(json));
      setLastUpdate(new Date().toLocaleTimeString());
      setLoading(false);
    });
    return () => { active = false };
  }, [partition]);

  // poll every second
  useEffect(() => {
    const iv = setInterval(async () => {
      const json = await fetchLiveSummary();
      setLiveCounts(json.realtime[partition]?.floors || {});
      setDetails(filterAndMap(json));
      setLastUpdate(new Date().toLocaleTimeString());
    }, 1000);
    return () => clearInterval(iv);
  }, [partition]);

  // group by floor name
  const floorMap = useMemo(() => {
    const m = {};
    Object.keys(liveCounts).forEach(f => { m[f] = [] });
    details.forEach(r => {
      if (!m[r.floor]) m[r.floor] = [];
      m[r.floor].push(r);
    });
    return m;
  }, [details, liveCounts]);

  // apply search filter to each floor's list
  // const displayed = useMemo(() => {
  //   const term = search.toLowerCase();
  //   return Object.entries(floorMap)
  //     .map(([floor, emps]) => {
  //       const filtered = emps.filter(e =>
  //         floor.toLowerCase().includes(term) ||
  //         e.ObjectName1?.toLowerCase().includes(term) ||
  //         `${e.EmployeeID}`.toLowerCase().includes(term) ||
  //         `${e.CardNumber}`.toLowerCase().includes(term)
  //       );
  //       return [floor, filtered];
  //     })
  //     .filter(([, emps]) => emps.length > 0);


  // }, [floorMap, search]);



  // apply search filter to each floor's list
  const displayed = useMemo(() => {
    const term = search.toLowerCase();

    const arr = Object.entries(floorMap)
      .map(([floor, emps]) => {
        const filtered = emps.filter(e =>
          floor.toLowerCase().includes(term) ||
          e.ObjectName1?.toLowerCase().includes(term) ||
          `${e.EmployeeID}`.toLowerCase().includes(term) ||
          `${e.CardNumber}`.toLowerCase().includes(term)
        );
        return [floor, filtered];
      })
      .filter(([, emps]) => emps.length > 0);

    // ✅ sort by length descending (largest totals first)
    arr.sort((a, b) => b[1].length - a[1].length);

    return arr;
  }, [floorMap, search]);



  const columns = [
    { field: "EmployeeID", headerName: "Emp ID" },
    { field: "ObjectName1", headerName: "Name" },
    { field: "LocaleMessageTime", headerName: "Swipe Time" },
    { field: "PersonnelType", headerName: "Type" },
    { field: "CompanyName", headerName: "Company" }, // <-- ADD THIS LINE
    { field: "Direction", headerName: "Direction" }, // <-- ADD THIS LINE
    { field: "CardNumber", headerName: "Card" },
    { field: "Door", headerName: "Door" },
  ];

  if (loading) {
    return (
      <>
        <Header />
        <Box sx={{ px: 2, py: 8 }}><LoadingSpinner /></Box>
        <Footer />
      </>
    );
  }

  return (
    <>
      <Header />
      <Box sx={{ pt: 1, pb: 1, background: "rgba(0,0,0,0.6)" }}>
        <Container disableGutters maxWidth={false}>

          {/* Back button + title */}
          <Box display="flex" alignItems="center" mb={2} sx={{ px: 2 }}>
            <Button size="small" onClick={() => navigate(-1)} sx={{ color: "#FFC107" }}>
              ← Back to Overview
            </Button>
          </Box>

          {/* Search + timestamp */}
          <Box display="flex" alignItems="center" gap={2} mb={2} sx={{ px: 2 }}>
            <Typography variant="h6" sx={{ color: "#FFC107" }}>
              Floor Details
            </Typography>

            {/* <Typography variant="body2" sx={{ color: "#FFC107" }}>
              Last updated: {lastUpdate}
            </Typography> */}

            <TextField
              size="small"
              placeholder="Search floor / emp…"
              value={search}
              onChange={e => setSearchTerm(e.target.value)}
              sx={{
                "& .MuiInputBase-input": { color: "#FFC107" },
                "& .MuiOutlinedInput-root fieldset": { borderColor: "#FFC107" }
              }}
            />
          </Box>

           {/* 3) replace the floor card JSX (the displayed.map rendering) with this updated version */}
          {/* Floor cards */}
          <Box display="flex" flexWrap="wrap" width="100%" sx={{ px: 2 }}>
            {displayed.map(([floor, emps]) => (
              <Box key={floor} sx={{ width: "50%", p: 2 }}>
                <Paper sx={{
                  border: "2px solid #FFC107",
                  p: 2,
                  background: "rgba(0,0,0,0.4)"
                }}>
                  {/* Header row: left = floor title, right = export button */}
                  <Box display="flex" alignItems="center" justifyContent="space-between" mb={1}>
                    <Typography
                      variant="subtitle1"
                      fontWeight={600}
                      sx={{ color: "#FFC107" }}
                    >
                      {floor} (Total {emps.length})
                    </Typography>

                    <Button
                      size="small"
                      variant="contained"
                      onClick={() => handleExportFloor(floor, emps)}
                      sx={{ bgcolor: '#FFC107', color: '#000', textTransform: 'none' }}
                    >
                      Export
                    </Button>
                  </Box>

                  <TableContainer
                    component={Paper}
                    variant="outlined"
                    sx={{ mb: 1, background: "rgba(0,0,0,0.4)" }}
                  >
                    <Table size="small">
                      <TableHead>
                        <TableRow sx={{ bgcolor: "#000" }}>
                          {["Emp ID", "Name", "Swipe Time", "Type", "Company","Direction", "Card", "Door"].map(h => (
                            <TableCell
                              key={h}
                              sx={{
                                color: "#FFC107",
                                border: "1px solid #FFC107",
                                fontWeight: "bold"
                              }}
                            >
                              {h}
                            </TableCell>
                          ))}
                        </TableRow>
                      </TableHead>
                      <TableBody>
                        {emps.slice(0, 10).map((r, i) => (
                          <TableRow key={i}>
                            <TableCell sx={{ color: "#fff", border: "1px solid #FFC107" }}>
                              {r.EmployeeID}
                            </TableCell>
                            <TableCell sx={{ color: "#fff", border: "1px solid #FFC107" }}>
                              {r.ObjectName1}
                            </TableCell>
                            <TableCell sx={{ color: "#fff", border: "1px solid #FFC107" }}>
                              {formatApiDateTime(r.LocaleMessageTime)}
                            </TableCell>
                            <TableCell sx={{ color: "#fff", border: "1px solid #FFC107" }}>
                              {r.PersonnelType}
                            </TableCell>
                            <TableCell sx={{ color: "#fff", border: "1px solid #FFC107" }}>
                              {r.CompanyName}
                            </TableCell>
                            <TableCell sx={{ color: "#fff", border: "1px solid #FFC107" }}>
                              {r.Direction}
                            </TableCell>
                            <TableCell sx={{ color: "#fff", border: "1px solid #FFC107" }}>
                              {r.CardNumber}
                            </TableCell>
                            <TableCell sx={{ color: "#fff", border: "1px solid #FFC107" }}>
                              {r.Door}
                            </TableCell>
                          </TableRow>
                        ))}
                      </TableBody>
                    </Table>
                  </TableContainer>

                  <Button
                    size="small"
                    onClick={() => setExpandedFloor(f => f === floor ? null : floor)}
                    sx={{ color: "#FFC107" }}
                  >
                    {expandedFloor === floor ? "Hide" : "See more…"}
                  </Button>
                </Paper>
              </Box>
            ))}
          </Box>



          {/* Expanded table */}
          {expandedFloor && (
            <Box sx={{ px: 2, mt: 2 }}>
              <Typography variant="h6" sx={{ color: "#FFC107" }} gutterBottom>
                {expandedFloor} — All Entries
              </Typography>

              <DataTable
                // add a Sr No column only for the expanded table (keeps original `columns` unchanged)
                columns={[{ field: "SrNo", headerName: "Sr No" }, ...columns]}
                rows={(floorMap[expandedFloor] || []).map((r, i) => ({
                  ...r,
                  LocaleMessageTime: formatApiDateTime(r.LocaleMessageTime),
                  SrNo: i + 1 // 1,2,3...
                }))}
              />
            </Box>
          )}





        </Container>
      </Box>
      <Footer />
    </>
  );
}





///////////
///////////




// APAC display mapping
const apacPartitionDisplay = {
  'IN.Pune': { country: 'India', city: 'Pune' },
  'MY.Kuala Lumpur': { country: 'Malaysia', city: 'Kuala Lumpur' },
  'PH.Quezon': { country: 'Philippines', city: 'Quezon City' },
  'PH.Taguig': { country: 'Philippines', city: 'Taguig' },
  'JP.Tokyo': { country: 'Japan', city: 'Tokyo' },
};

// FE ↔ BE keys
const apacForwardKey = {
  'IN.Pune': 'Pune',
  'MY.Kuala Lumpur': 'MY.Kuala Lumpur',
  'PH.Quezon': 'Quezon City',
  'PH.Taguig': 'Taguig City',
  'JP.Tokyo': 'JP.Tokyo',
};
const apacReverseKey = Object.fromEntries(
  Object.entries(apacForwardKey).map(([fe, be]) => [be, fe])
);

// helper to display “Quezon City” → “Quezon City”
const formatPartition = key => {
  const fe = apacReverseKey[key];
  return fe
    ? apacPartitionDisplay[fe].city
    : key;
};

// helper: unify the key format used by companyRows and detailRows
const makeCompanyKey = (country, city, company) => `${country}||${city}||${company}`;


export default function History() {
  const { partition } = useParams();
  const decodedPartition = partition ? decodeURIComponent(partition) : null;
  const backendFilterKey = decodedPartition
    ? apacForwardKey[decodedPartition] || decodedPartition
    : null;

  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [pickedDate, setPickedDate] = useState(null);
  const [showDetails, setShowDetails] = useState(false);




  // new: company click/filter state
  const [selectedCompany, setSelectedCompany] = useState(null);


  useEffect(() => {
    setLoading(true);
    fetchHistory(decodedPartition)
      .then(json => {
        setData(json);
      })
      .finally(() => setLoading(false));
  }, [decodedPartition]);


  // clear company selection when date changes
  useEffect(() => {
    setSelectedCompany(null);
  }, [pickedDate]);


  const summaryEntry = useMemo(() => {
    if (!data || !pickedDate) return null;
    const ds = format(pickedDate, 'yyyy-MM-dd');
    return data.summaryByDate.find(r =>
      r.date === ds || r.date.startsWith(ds)
    ) || null;
  }, [data, pickedDate]);

  const partitionRows = useMemo(() => {
    if (!summaryEntry) return [];
    if (backendFilterKey && summaryEntry.region) {
      const fe = Object.keys(apacPartitionDisplay).find(
        code => apacForwardKey[code] === backendFilterKey || code === backendFilterKey
      );
      const disp = fe ? apacPartitionDisplay[fe] : {};
      return [{
        country: disp.country || 'Unknown',
        city: disp.city || backendFilterKey.replace(' City', ''),
        employee: summaryEntry.region.Employee || 0,
        contractor: summaryEntry.region.Contractor || 0,
        total: summaryEntry.region.total || 0
      }];
    }
    return Object.entries(summaryEntry.partitions).map(([key, v]) => {
      const fe = Object.entries(apacForwardKey).find(([, be]) =>
        be === key || `${be} City` === key
      )?.[0];
      const disp = fe
        ? apacPartitionDisplay[fe]
        : Object.values(apacPartitionDisplay)
          .find(d => d.city === key.replace(' City', ''));
      return {
        country: disp?.country || 'Unknown',
        city: disp?.city || key.replace(' City', ''),
        employee: v.Employee || v.EmployeeCount || 0,
        contractor: v.Contractor || v.ContractorCount || 0,
        total: v.total || 0
      };
    });
  }, [summaryEntry, backendFilterKey]);



  const formatApiTime12 = iso => {
    if (!iso) return "";
    // get HH:MM:SS part from ISO like "2025-08-28T10:22:33.000Z"
    const tp = (iso && iso.slice(11, 19)) || "";
    if (!tp) return "";
    const [hStr, mStr, sStr] = tp.split(':');   // ✅ now include seconds
    const hh = parseInt(hStr, 10);
    if (Number.isNaN(hh)) return tp;
    let h12 = hh % 12;
    if (h12 === 0) h12 = 12;
    const ampm = hh >= 12 ? "PM" : "AM";
    return `${String(h12).padStart(2, "0")}:${mStr}:${sStr} ${ampm}`;
  };


  // --- company name normalizer ---
  // keep it deterministic and conservative (only maps the families you listed)
  const normalizeCompany = (raw) => {
    if (!raw) return 'Unknown';
    // trim and collapse whitespace
    const orig = String(raw).trim();
    const s = orig
      .toLowerCase()
      // remove punctuation commonly causing variants
      .replace(/[.,()\/\-]/g, ' ')
      .replace(/\s+/g, ' ')
      .trim();

    // Poona / Poona Security family
    if (/\bpoona\b/.test(s) || /\bpoona security\b/.test(s) || /\bpoona security india\b/.test(s)) {
      return 'Poona Security India Pvt Ltd';
    }

    // Western Union family (map many variants to single canonical)
    if (
      /\bwestern union\b/.test(s) ||
      /\bwesternunion\b/.test(s) ||
      /\bwu\b/.test(s) ||           // WU standalone
      /\bwufs\b/.test(s) ||         // WUFS variants
      /\bwu technology\b/.test(s) ||
      /\bwu srvcs\b/.test(s) ||
      /\bwestern union svs\b/.test(s) ||
      /\bwestern union processing\b/.test(s) ||
      /\bwestern union japan\b/.test(s) ||
      /\bwestern union, llc\b/.test(s)
    ) {
      return 'Western Union';
    }

    // Vedant family
    if (/\bvedant\b/.test(s)) {
      return 'Vedant Enterprises Pvt. Ltd';
    }

    // Osource family
    if (/\bosource\b/.test(s)) {
      return 'Osource India Pvt Ltd';
    }

    // CBRE family
    if (/\bcbre\b/.test(s)) {
      return 'CBRE';
    }

    // explicit Unknown canonical
    if (s === 'unknown' || s === '') return 'Unknown';

    // otherwise return the original trimmed string (preserve casing)
    return orig;
  };



  // helper: compute canonical company for a single detail row (same logic used by companyRows)
  const getCanonicalCompany = (r) => {
    const rawCompany = (r.CompanyName || '').toString().trim();
    const pt = (r.PersonnelType || '').toString().trim().toLowerCase();
    const s = rawCompany.toLowerCase();

    // If CompanyName contains CBRE and also mention of CLR or Facility -> CLR canonical
    if (s && /\bcbre\b/.test(s) && (/\bclr\b/.test(s) || /\bfacilit/i.test(s))) {
      return 'CLR Facility Services Pvt.Ltd.';
    }

    // If CompanyName is explicitly CBRE (or normalizes to CBRE)
    // and PersonnelType indicates Property Management -> map to CLR Facility Services
    if (s && (s === 'cbre' || normalizeCompany(rawCompany) === 'CBRE')) {
      if (pt.includes('property') || pt.includes('management') || pt === 'property management') {
        // NEW: map CBRE + Property Management -> CLR Facility Services (single canonical)
        return 'CLR Facility Services Pvt.Ltd.';
      }
      // otherwise keep as CBRE
      return 'CBRE';
    }

    // If CompanyName is blank -> use PersonnelType fallback rules
    if (!rawCompany) {
      if (pt.includes('contractor')) return 'CBRE';
      if (pt.includes('property') || pt.includes('management') || pt === 'property management') {
        // blank company but property-management -> CLR Facility Services (same canonical)
        return 'CLR Facility Services Pvt.Ltd.';
      }
      if (pt === 'employee') return 'Western Union';
      if (pt.includes('visitor')) return 'Visitor';
      if (pt.includes('temp')) return 'Temp Badge';
      return 'Unknown';
    }

    // otherwise use normalizeCompany for other families
    return normalizeCompany(rawCompany);
  };


  const detailRows = useMemo(() => {
    if (!data || !pickedDate || !showDetails) return [];
    const ds = format(pickedDate, 'yyyy-MM-dd');

    return data.details
      .filter(r => {
        // match date
        if (!r.LocaleMessageTime || r.LocaleMessageTime.slice(0, 10) !== ds) return false;

        // partition (city) filter
        if (backendFilterKey) {
          const ok = r.PartitionNameFriendly === backendFilterKey ||
            apacForwardKey[r.PartitionNameFriendly] === backendFilterKey;
          if (!ok) return false;
        }

        // if no company selected, include everything
        if (!selectedCompany) return true;

        // compute country & city the same way companyRows does
        const city = formatPartition(r.PartitionNameFriendly || '');
        const disp = Object.values(apacPartitionDisplay).find(d => d.city === city);
        const country = disp?.country || 'Unknown';

        // canonical company name for this row
        const canonical = getCanonicalCompany(r);

        // build key and compare
        const rowKey = makeCompanyKey(country, city, canonical);
        return rowKey === selectedCompany;
      })
      .sort((a, b) => a.LocaleMessageTime.localeCompare(b.LocaleMessageTime));
  }, [data, pickedDate, showDetails, backendFilterKey, selectedCompany]);




  // companyRows: aggregated by normalized CompanyName for pickedDate (respects backendFilterKey)
  const companyRows = useMemo(() => {
    if (!data || !pickedDate) return [];

    const ds = format(pickedDate, 'yyyy-MM-dd');

    // filter details for the date + optional partition filter
    const filtered = data.details.filter(r =>
      r.LocaleMessageTime && r.LocaleMessageTime.slice(0, 10) === ds &&
      (
        !backendFilterKey ||
        r.PartitionNameFriendly === backendFilterKey ||
        apacForwardKey[r.PartitionNameFriendly] === backendFilterKey
      )
    );

    // aggregate into map: key = country||city||normalizedCompany
    const map = new Map();

    filtered.forEach(r => {
      const city = formatPartition(r.PartitionNameFriendly || '');
      const disp = Object.values(apacPartitionDisplay).find(d => d.city === city);
      const country = disp?.country || 'Unknown';

      // use the shared canonical helper so companyRows and detail filtering match exactly
      const company = getCanonicalCompany(r);

      const key = `${country}||${city}||${company}`;
      const existing = map.get(key);
      if (existing) {
        existing.total += 1; // counting rows as "total" (same behaviour as before)
      } else {
        map.set(key, { country, city, company, total: 1 });
      }
    });

    // return sorted list (optional: by country, city, company)
    return Array.from(map.values()).sort((a, b) => {
      if (a.country !== b.country) return a.country.localeCompare(b.country);
      if (a.city !== b.city) return a.city.localeCompare(b.city);
      return a.company.localeCompare(b.company);
    });
  }, [data, pickedDate, backendFilterKey]);



  const handleExport = async () => {
    if (!pickedDate || !detailRows.length) return;

    const workbook = new ExcelJS.Workbook();
    const sheet = workbook.addWorksheet("Details");

    // --- Top date row (merged across all columns) ---

    sheet.mergeCells(1, 1, 1, 11); // merge across 11 columns
    const titleCell = sheet.getCell("A1");
    titleCell.value = format(pickedDate, "EEEE, d MMMM, yyyy");
    titleCell.alignment = { horizontal: "center", vertical: "middle" };
    titleCell.font = { bold: true, size: 14 };

    // --- Header row ---
    const headers = [
      "Sr",
      "Date",
      "Time",
      "Employee ID",
      "Card Number",
      "Name",
      "Personnel Type",
      "Company",
      "Primary Location",
      "Door",
      "Partition"
    ];
    const headerRow = sheet.addRow(headers);
    headerRow.eachCell(cell => {
      cell.font = { bold: true, color: { argb: "0a0a0a" } };
      cell.fill = {
        type: "pattern",
        pattern: "solid",
        fgColor: { argb: "FFFFC107" }
      };
      cell.alignment = { horizontal: "center", vertical: "middle" };
      cell.border = {
        top: { style: "thin" },
        left: { style: "thin" },
        bottom: { style: "thin" },
        right: { style: "thin" }
      };
    });

    // --- Data rows ---
    detailRows.forEach((r, i) => {
      const row = sheet.addRow([
        i + 1,
        r.LocaleMessageTime ? r.LocaleMessageTime.slice(0, 10) : "",
        formatApiTime12(r.LocaleMessageTime),
        r.EmployeeID,
        r.CardNumber,
        r.ObjectName1,
        r.PersonnelType,
        r.CompanyName,
        r.PrimaryLocation,
        r.Door,
        formatPartition(r.PartitionNameFriendly)
      ]);
      row.eachCell(cell => {
        cell.border = {
          top: { style: "thin" },
          left: { style: "thin" },
          bottom: { style: "thin" },
          right: { style: "thin" }
        };
      });
    });

    // --- Set explicit/sensible widths and alignments ---
    // ExcelJS column index is 1-based. We'll set fixed widths for small columns
    // and auto-size the rest with minimal padding.
    // Map: A=Sr, B=Date, C=Time, D=Employee ID, E=Card Number, F=Name, G=Personnel Type,
    // H=Company, I=Primary Location, J=Door, K=Partition

    // First set some defaults (will override specific ones after)
    sheet.columns = [
      { key: 'sr' },           // A
      { key: 'date' },         // B
      { key: 'time' },         // C
      { key: 'empid' },        // D
      { key: 'card' },         // E
      { key: 'name' },         // F
      { key: 'ptype' },        // G
      { key: 'company' },      // H
      { key: 'ploc' },         // I
      { key: 'door' },         // J
      { key: 'partition' }     // K
    ];

    // Explicit compact widths for narrow/ID columns (these are character widths)
    const explicitWidths = {
      1: 7,   // Sr
      2: 12,  // Date (yyyy-mm-dd is 10 chars; give a little room)
      3: 13,  // Time (hh:mm:ss AM)
      4: 12,  // Employee ID (IDs are short)
      5: 12,
      6: 25,
      8: 25,  // Card Number (short)
      10: 50
      // other columns will be auto-sized below
    };

    // auto-size remaining columns but with minimal padding
    // compute max length per column from cells (including header)
    const maxLens = new Array(sheet.columns.length).fill(0);
    sheet.eachRow((row, rowNumber) => {
      row.eachCell((cell, colNumber) => {
        const text = cell.value === null || cell.value === undefined ? '' : String(cell.value);
        // don't count long strings with weird spacing — trim for measurement
        const len = text.trim().length;
        if (len > maxLens[colNumber - 1]) maxLens[colNumber - 1] = len;
      });
    });

    // apply widths: use explicit widths where given, otherwise use measured length + small padding
    sheet.columns.forEach((col, idx) => {
      const colIndex = idx + 1;
      if (explicitWidths[colIndex]) {
        col.width = explicitWidths[colIndex];
      } else {
        // small padding: +1 (instead of +2 previously) and min 8, max 40
        const measured = maxLens[idx] || 8;
        const width = Math.min(Math.max(measured + 1, 8), 40);
        col.width = width;
      }


    });

    // Optional: freeze the header row to keep it visible when scrolling in Excel
    sheet.views = [{ state: 'frozen', ySplit: 1 }];

    // --- Save file ---
    const buf = await workbook.xlsx.writeBuffer();
    saveAs(new Blob([buf]), `apac_history_${format(pickedDate, "yyyyMMdd")}.xlsx`);
  };








  // UPDATED: prettier Excel export for summary (date centered, full borders, header styling, spacing, column widths)

  const handleExportSummary = async () => {
    if (!pickedDate) return;

    // workbook / sheet
    const wb = new ExcelJS.Workbook();
    const ws = wb.addWorksheet('Summary');

    // columns (widths)
    ws.columns = [
      { header: 'Country', key: 'country', width: 20 },
      { header: 'City', key: 'city', width: 25 },
      { header: 'Employees', key: 'employees', width: 12 },
      { header: 'Contractors', key: 'contractors', width: 12 },
      { header: 'Total', key: 'total', width: 12 },
    ];

    // Row 1: merged date centered
    ws.mergeCells('A1:E1');
    const dateCell = ws.getCell('A1');
    dateCell.value = format(pickedDate, 'EEEE, d MMMM, yyyy');
    dateCell.alignment = { horizontal: 'center', vertical: 'middle' };
    dateCell.font = { name: 'Calibri', size: 14, bold: true };

    // Row 2: blank spacing
    ws.addRow([]);

    // Row 3: header row (we'll style it)
    const headerRow = ws.addRow(['Country', 'City', 'Employees', 'Contractors', 'Total']);
    headerRow.height = 20;

    // style helpers
    const thinBorder = { style: 'thin', color: { argb: 'FF000000' } };
    const allThinBorder = { top: thinBorder, left: thinBorder, bottom: thinBorder, right: thinBorder };

    // header style: yellow fill, bold, centered
    headerRow.eachCell(cell => {
      cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFC107' } }; // yellow
      cell.font = { name: 'Calibri', size: 12, bold: true, color: { argb: 'FF000000' } };
      cell.alignment = { horizontal: 'center', vertical: 'middle' };
      cell.border = allThinBorder;
    });

    // Row 4: blank spacing (visual)
    ws.addRow([]);

    // Data rows start at excelRowIndex = current row number + 1
    partitionRows.forEach(r => {
      const row = ws.addRow([r.country, r.city, r.employee, r.contractor, r.total]);
      // style cells & numeric formatting
      row.eachCell((cell, colNumber) => {
        cell.border = allThinBorder;
        if (colNumber >= 3) {
          // numeric columns: right align, number format
          cell.alignment = { horizontal: 'right', vertical: 'middle' };
          if (cell.value !== null && cell.value !== undefined && cell.value !== '') {
            cell.numFmt = '#,##0';
          }
        } else {
          cell.alignment = { horizontal: 'left', vertical: 'middle' };
        }
        cell.font = { name: 'Calibri', size: 11, color: { argb: 'FF000000' } };
      });
    });

    // Final total row
    const totalEmployees = partitionRows.reduce((s, r) => s + r.employee, 0);
    const totalContractors = partitionRows.reduce((s, r) => s + r.contractor, 0);
    const totalTotal = partitionRows.reduce((s, r) => s + r.total, 0);
    const totalRow = ws.addRow(['Total', '', totalEmployees, totalContractors, totalTotal]);

    // style total row: bold and light-gray fill
    totalRow.eachCell((cell, colNumber) => {
      cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFD9D9D9' } }; // light gray
      cell.font = { name: 'Calibri', size: 12, bold: true, color: { argb: 'FF000000' } };
      cell.border = allThinBorder;
      if (colNumber >= 3) {
        cell.alignment = { horizontal: 'right', vertical: 'middle' };
        cell.numFmt = '#,##0';
      } else {
        cell.alignment = { horizontal: colNumber === 1 ? 'left' : 'center', vertical: 'middle' };
      }
    });

    // Freeze panes so header is visible (freeze above data rows: after row 4)
    ws.views = [{ state: 'frozen', ySplit: 4 }];

    // Optional: set sheet outline or table-like styling can be added here

    // export
    const buf = await wb.xlsx.writeBuffer();
    const safeDate = format(pickedDate, 'yyyyMMdd');
    const filename = `apac_summary_${safeDate}.xlsx`;
    saveAs(new Blob([buf]), filename);
  };



  const handleExportCompanies = async () => {
    if (!pickedDate || !companyRows.length) return;

    const wb = new ExcelJS.Workbook();
    const ws = wb.addWorksheet('Company Summary');

    // set up columns
    ws.columns = [
      { header: 'Country', key: 'country', width: 20 },
      { header: 'City', key: 'city', width: 25 },
      { header: 'Company', key: 'company', width: 40 },
      { header: 'Total', key: 'total', width: 12 },
    ];

    // merge top row for date
    ws.mergeCells('A1:D1');
    const dateCell = ws.getCell('A1');
    dateCell.value = format(pickedDate, 'EEEE, d MMMM, yyyy');
    dateCell.alignment = { horizontal: 'center', vertical: 'middle' };
    dateCell.font = { name: 'Calibri', size: 14, bold: true };

    // blank spacer
    ws.addRow([]);

    // header row
    const headerRow = ws.addRow(['Country', 'City', 'Company', 'Total']);
    headerRow.eachCell(cell => {
      cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFC107' } };
      cell.font = { bold: true, color: { argb: 'FF000000' } };
      cell.alignment = { horizontal: 'center', vertical: 'middle' };
      cell.border = {
        top: { style: 'thin' },
        left: { style: 'thin' },
        bottom: { style: 'thin' },
        right: { style: 'thin' }
      };
    });

    // data rows
    companyRows.forEach(r => {
      const row = ws.addRow([r.country, r.city, r.company, r.total]);
      row.eachCell((cell, colNumber) => {
        cell.border = {
          top: { style: 'thin' },
          left: { style: 'thin' },
          bottom: { style: 'thin' },
          right: { style: 'thin' }
        };
        if (colNumber === 4) {
          cell.alignment = { horizontal: 'right', vertical: 'middle' };
          cell.numFmt = '#,##0';
        } else {
          cell.alignment = { horizontal: 'left', vertical: 'middle' };
        }
      });
    });

    // totals row
    const total = companyRows.reduce((s, r) => s + r.total, 0);
    const totalRow = ws.addRow(['Total', '', '', total]);
    totalRow.eachCell((cell, colNumber) => {
      cell.font = { bold: true };
      cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFD9D9D9' } };
      cell.border = {
        top: { style: 'thin' },
        left: { style: 'thin' },
        bottom: { style: 'thin' },
        right: { style: 'thin' }
      };
      if (colNumber === 4) {
        cell.alignment = { horizontal: 'right', vertical: 'middle' };
        cell.numFmt = '#,##0';
      } else {
        cell.alignment = { horizontal: colNumber === 1 ? 'left' : 'center', vertical: 'middle' };
      }
    });

    // save
    const buf = await wb.xlsx.writeBuffer();
    saveAs(new Blob([buf]), `apac_companies_${format(pickedDate, "yyyyMMdd")}.xlsx`);
  };



  if (loading) return <LoadingSpinner />;
  if (!data) return null;

  const datePickerSx = {
    backgroundColor: '#000',
    '& .MuiOutlinedInput-notchedOutline': { borderColor: '#FFC107' },
    '&:hover .MuiOutlinedInput-notchedOutline': { borderColor: '#FFC107' },
    '& .MuiInputBase-input': { color: '#FFC107' },
    '& .MuiInputLabel-root': { color: '#FFC107' },
    '& .MuiInputAdornment-root svg': { color: '#FFC107' },
  };

  return (
    <>
      <Header />
      <Container maxWidth={false} disableGutters sx={{ pt: 2, pb: 4 }}>
        {/* ‣ Date & summary */}
        {pickedDate && summaryEntry ? (

          <Box display="flex" alignItems="flex-start" sx={{ px: 2, mb: 2, gap: 2 }}>
            <Box sx={{ width: 200 }}>
              <LocalizationProvider dateAdapter={AdapterDateFns}>
                <DatePicker
                  label="Select date"
                  value={pickedDate}
                  onChange={d => { setPickedDate(d); setShowDetails(false); }}
                  renderInput={params => <TextField fullWidth {...params} sx={datePickerSx} />}
                />
              </LocalizationProvider>
            </Box>

            {/* Container for both tables side-by-side */}

            <Box sx={{ display: 'flex', gap: 2, width: '100%', flexWrap: { xs: 'wrap', md: 'nowrap' } }}>
              {/* Left: existing summary table */}

              <Box sx={{ flex: 1, minWidth: 320 }}>

                <Paper elevation={3} sx={{ p: 3, border: '3px solid #000', borderRadius: 2 }}>
                  <TableContainer sx={{ maxHeight: 500, overflowY: 'auto' }}>

                    <Table sx={{ border: '2px solid #000' }} size="small">
                      <TableHead>
                        <TableRow>
                          <TableCell colSpan={5} align="center"
                            sx={{ fontWeight: 'bold', fontSize: 16, bgcolor: '#000', color: '#FFC107', border: '2px solid #000' }}>
                            {format(pickedDate, 'EEEE, d MMMM, yyyy')}
                          </TableCell>
                        </TableRow>
                        <TableRow sx={{ bgcolor: '#FFC107' }}>
                          {['Country', 'City', 'Employees', 'Contractors', 'Total'].map(h => (
                            <TableCell key={h} align={h === 'Country' || h === 'City' ? 'left' : 'right'}
                              sx={{ color: '#000', fontWeight: 'bold', fontSize: 14, border: '2px solid #000' }}>
                              {h}
                            </TableCell>
                          ))}
                        </TableRow>
                      </TableHead>
                      <TableBody>
                        {partitionRows.map((r, i) => (
                          <TableRow key={i}>
                            <TableCell sx={{ border: '2px solid #000' }}>{r.country}</TableCell>
                            <TableCell sx={{ border: '2px solid #000' }}>{r.city}</TableCell>
                            <TableCell align="right" sx={{ border: '2px solid #000' }}>{r.employee}</TableCell>
                            <TableCell align="right" sx={{ border: '2px solid #000' }}>{r.contractor}</TableCell>
                            <TableCell align="right" sx={{ bgcolor: '#FFC107', fontWeight: 'bold', border: '2px solid #000' }}>
                              {r.total}
                            </TableCell>
                          </TableRow>
                        ))}
                        <TableRow sx={{ bgcolor: '#666' }}>
                          <TableCell colSpan={2} align="right" sx={{ color: '#fff', fontWeight: 'bold', border: '2px solid #000' }}>
                            Total
                          </TableCell>
                          <TableCell align="right" sx={{ color: '#fff', fontWeight: 'bold', border: '2px solid #000' }}>
                            {partitionRows.reduce((s, r) => s + r.employee, 0)}
                          </TableCell>
                          <TableCell align="right" sx={{ color: '#fff', fontWeight: 'bold', border: '2px solid #000' }}>
                            {partitionRows.reduce((s, r) => s + r.contractor, 0)}
                          </TableCell>
                          <TableCell align="right" sx={{ color: '#fff', fontWeight: 'bold', bgcolor: '#333', border: '2px solid #000' }}>
                            {partitionRows.reduce((s, r) => s + r.total, 0)}
                          </TableCell>
                        </TableRow>
                      </TableBody>
                    </Table>
                  </TableContainer>
                </Paper>

                <Box display="flex" justifyContent="center" sx={{ mt: 1 }}>
                  <Button variant="contained" sx={{ bgcolor: '#FFC107', color: '#000' }}
                    onClick={() => setShowDetails(v => !v)}>
                    {showDetails ? 'Hide Details' : 'See Details'}
                  </Button>
                  {showDetails && (
                    <Button variant="outlined" sx={{ ml: 2, borderColor: '#FFC107', color: '#FFC107' }}
                      onClick={handleExport}>
                      Export to Excel
                    </Button>
                  )}
                  <Button
                    variant="contained"
                    sx={{ ml: 2, bgcolor: '#FFC107', color: '#000' }}
                    onClick={handleExportSummary}
                  >
                    Export Summary to Excel
                  </Button>
                </Box>
              </Box>

              {/* Right: NEW company-level table (same style) */}

              <Box sx={{ flex: 1, minWidth: 320 }}>

                <Paper elevation={3} sx={{ p: 3, border: '3px solid #000', borderRadius: 2 }}>
                  <TableContainer sx={{ maxHeight: 280, overflowY: 'auto' }}>

                    <Table sx={{ border: '2px solid #000' }} size="small">
                      <TableHead>
                        <TableRow>
                          <TableCell colSpan={4} align="center"
                            sx={{ fontWeight: 'bold', fontSize: 16, bgcolor: '#000', color: '#FFC107', border: '2px solid #000' }}>
                            {format(pickedDate, 'EEEE, d MMMM, yyyy')}
                          </TableCell>
                        </TableRow>
                        <TableRow sx={{ bgcolor: '#FFC107' }}>
                          {['Country', 'City', 'Company', 'Total'].map(h => (
                            <TableCell key={h} align={h === 'Country' || h === 'City' ? 'left' : 'center'}
                              sx={{ color: '#000', fontWeight: 'bold', fontSize: 14, border: '2px solid #000' }}>
                              {h}
                            </TableCell>
                          ))}
                        </TableRow>
                      </TableHead>
                      <TableBody>

                        {companyRows.length > 0 ? companyRows.map((r, i) => {
                          const rowKey = makeCompanyKey(r.country, r.city, r.company);
                          return (
                            <TableRow
                              key={`${r.company}-${i}`}
                              onClick={() => {
                                if (selectedCompany === rowKey) {
                                  setSelectedCompany(null);   // second click — clear filter
                                  setShowDetails(true);
                                } else {
                                  setSelectedCompany(rowKey); // first click — filter
                                  setShowDetails(true);
                                }
                              }}
                              sx={{
                                cursor: 'pointer',
                                '&:hover': { backgroundColor: '#474747' },
                                ...(selectedCompany === rowKey ? { backgroundColor: '#474747' } : {})
                              }}
                              tabIndex={0}
                              role="button"
                              onKeyDown={(e) => {
                                if (e.key === 'Enter' || e.key === ' ') {
                                  e.preventDefault();
                                  if (selectedCompany === rowKey) {
                                    setSelectedCompany(null);
                                    setShowDetails(true);
                                  } else {
                                    setSelectedCompany(rowKey);
                                    setShowDetails(true);
                                  }
                                }
                              }}
                            >
                              <TableCell sx={{ border: '2px solid #000' }}>{r.country}</TableCell>
                              <TableCell sx={{ border: '2px solid #000' }}>{r.city}</TableCell>
                              <TableCell sx={{ border: '2px solid #000' }}>{r.company}</TableCell>
                              <TableCell align="right" sx={{ bgcolor: '#FFC107', fontWeight: 'bold', border: '2px solid #000' }}>
                                {r.total}
                              </TableCell>
                            </TableRow>
                          );
                        }):(
                            <TableRow>
                              <TableCell colSpan={4} sx={{ border: '2px solid #000', textAlign: 'center', color: '#666', fontStyle: 'italic' }}>
                                No records for this date.
                              </TableCell>
                            </TableRow>
                          )}

                        {/* Totals row */}
                        <TableRow sx={{ bgcolor: '#666' }}>
                          <TableCell colSpan={2} align="right" sx={{ color: '#fff', fontWeight: 'bold', border: '2px solid #000' }}>
                            Total
                          </TableCell>
                          <TableCell align="right" sx={{ color: '#fff', fontWeight: 'bold', border: '2px solid #000' }}>
                            {/* empty cell for layout: keep consistent with left table */}
                          </TableCell>
                          <TableCell align="right" sx={{ color: '#fff', fontWeight: 'bold', bgcolor: '#333', border: '2px solid #000' }}>
                            {companyRows.reduce((s, r) => s + r.total, 0)}
                          </TableCell>
                        </TableRow>
                      </TableBody>
                    </Table>
                  </TableContainer>
                </Paper>


                <Box display="flex" justifyContent="center" sx={{ mt: 1 }}>
                  <Button
                    variant="contained"
                    sx={{ bgcolor: '#FFC107', color: '#000' }}
                    onClick={handleExportCompanies}
                  >
                    Export Companies to Excel
                  </Button>
                </Box>
              </Box>
            </Box>
          </Box>

        ) : (
          <Box sx={{ px: 2, mb: 3 }}>
            <LocalizationProvider dateAdapter={AdapterDateFns}>
              <DatePicker
                label="Select date"
                value={pickedDate}
                onChange={d => { setPickedDate(d); setShowDetails(false); }}
                renderInput={params => <TextField fullWidth {...params} sx={datePickerSx} />}
              />
            </LocalizationProvider>
            {!pickedDate && (
              <Typography variant="body1" color="textSecondary" sx={{ mt: 2 }}>
                Please pick a date to view region summary.
              </Typography>
            )}
          </Box>
        )}

        {/* ‣ Details */}
        {showDetails && (
          <Box display="flex" justifyContent="center" mb={0} sx={{ width: '100%' }}>
            <Paper elevation={1} sx={{ p: 1, width: '100%', border: '3px solid #000', borderRadius: 2 }}>
              {detailRows.length > 0 ? (

                <Table sx={{ border: '2px solid #000', borderCollapse: 'collapse' }} size='small'>
                  <TableHead>
                    <TableRow sx={{ bgcolor: '#000' }}>
                      {[
                        'Sr', 'Date', 'Time',
                        'Employee ID', 'Card Number', 'Name', 'Personnel Type', 'CompanyName', 'PrimaryLocation',
                        'Door', 'Partition'
                      ].map(h => (
                        <TableCell key={h} align="center"
                          sx={{ color: '#FFC107', fontWeight: 'bold', fontSize: 14, border: '2px solid #000' }}>
                          {h}
                        </TableCell>
                      ))}
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    {detailRows.map((r, i) => (
                      <TableRow key={`${r.PersonGUID}-${i}`}>
                        <TableCell sx={{ border: '2px solid #000', whiteSpace: 'nowrap' }}>{i + 1}</TableCell>
                        <TableCell sx={{ border: '2px solid #000' }}>{r.LocaleMessageTime.slice(0, 10)}</TableCell>
                        <TableCell sx={{ border: '2px solid #000', whiteSpace: 'nowrap' }}>
                          {formatApiTime12(r.LocaleMessageTime)}
                        </TableCell>
                        <TableCell sx={{ border: '2px solid #000' }}>{r.EmployeeID}</TableCell>
                        <TableCell sx={{ border: '2px solid #000' }}>{r.CardNumber}</TableCell>
                        <TableCell sx={{ border: '2px solid #000' }}>{r.ObjectName1}</TableCell>
                        <TableCell sx={{ border: '2px solid #000' }}>{r.PersonnelType}</TableCell>
                        <TableCell sx={{ border: '2px solid #000' }}>{r.CompanyName}</TableCell>
                        <TableCell sx={{ border: '2px solid #000' }}>{r.PrimaryLocation}</TableCell>
                        <TableCell sx={{ border: '2px solid #000' }}>{r.Door}</TableCell>
                        <TableCell sx={{ border: '2px solid #000' }}>
                          {formatPartition(r.PartitionNameFriendly)}
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              ) : (
                <Typography variant="body2" sx={{ color: '#666', textAlign: 'center', mt: 2, fontStyle: 'italic' }}>
                  No swipe records found for this date.
                </Typography>
              )}
            </Paper>
          </Box>
        )}



      </Container>
      <Footer />
    </>
  );
}
