//C:\Users\W0024618\Desktop\apac-occupancy-backend\src\services\occupancy.service.js

const { poolPromise, sql } = require('../config/db');

const partitionList = [
  'APAC.Default',
  'CN.Beijing',
  'JP.Tokyo',
  'PH.Manila',
  'MY.Kuala Lumpur',
  'IN.Pune',
  'IN.HYD',
  'SG.Singapore'

];

function quoteList(arr) {
  return arr.map(p => `'${p.replace("'", "''")}'`).join(',');
}

/**
 * Live occupancy (today) for APAC
 */
exports.fetchLiveOccupancy = async () => {
  const pool = await poolPromise;
  const parts = quoteList(partitionList);

  const query = `
    WITH CombinedEmployeeData AS (
      SELECT
        t1.ObjectName1,
        t1.ObjectName2             AS Door,               -- include Door
        CASE WHEN t2.Int1 = 0 THEN t2.Text12 ELSE CAST(t2.Int1 AS NVARCHAR) END AS EmployeeID,
        t3.Name                    AS PersonnelType,
        t1.ObjectIdentity1         AS PersonGUID,
      t2.Text4                   AS CompanyName,   -- ✅ company
        t2.Text5                   AS PrimaryLocation, -- ✅ location         

        -- extract CardNumber from XML or shred table
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
          sc.value
        )                          AS CardNumber,
        CASE
          WHEN t1.ObjectName2 LIKE 'APAC_PI%' THEN 'Taguig City'
          WHEN t1.ObjectName2 LIKE 'APAC_PH%' THEN 'Quezon City'
          WHEN t1.ObjectName2 LIKE '%PUN%'   THEN 'Pune'
          WHEN t1.ObjectName2 LIKE 'APAC_JPN%' THEN 'JP.Tokyo'
          WHEN t1.ObjectName2 LIKE 'APAC_MY%'  THEN 'MY.Kuala Lumpur'
          WHEN t1.ObjectName2 LIKE 'IN.HYD%'  THEN 'IN.HYD'
           WHEN t1.ObjectName2 LIKE 'SG.Singapore%'  THEN 'SG.Singapore'
          ELSE t1.PartitionName2
        END                        AS PartitionName2,
        DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
        t5d.value                  AS Direction
      FROM ACVSUJournal_00010030.dbo.ACVSUJournalLog t1
      JOIN ACVSCore.Access.Personnel       t2 ON t1.ObjectIdentity1 = t2.GUID
      JOIN ACVSCore.Access.PersonnelType   t3 ON t2.PersonnelTypeID = t3.ObjectID
      LEFT JOIN ACVSUJournal_00010030.dbo.ACVSUJournalLogxmlShred t5d
        ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
      LEFT JOIN ACVSUJournal_00010030.dbo.ACVSUJournalLogxml t_xml
        ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, value
        FROM ACVSUJournal_00010030.dbo.ACVSUJournalLogxmlShred
        WHERE Name IN ('Card','CHUID')
      ) AS sc
        ON t1.XmlGUID = sc.GUID
      WHERE
        t1.MessageType = 'CardAdmitted'
        AND t1.PartitionName2 IN (${parts})
        AND CONVERT(DATE, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC))
            = CONVERT(DATE, GETDATE())
    ), Ranked AS (
      SELECT *,
        ROW_NUMBER() OVER (PARTITION BY PersonGUID ORDER BY LocaleMessageTime DESC) AS rn
      FROM CombinedEmployeeData
    )
    SELECT
      ObjectName1,
      Door,                            -- door
      PersonnelType,
      EmployeeID,
      CardNumber,                      -- now returned
      PartitionName2,
      LocaleMessageTime,
      Direction,
      PersonGUID,
     CompanyName,  
      PrimaryLocation
    FROM Ranked
    WHERE rn = 1;
  `;

  const result = await pool.request().query(query);
  return result.recordset;
};




/**
 * Historical raw‐data fetch for the past N days, all or by location.
 */


exports.fetchHistoricalData = async ({ days = 15, location = null }) => {
  const pool = await poolPromise;
  const parts = quoteList(partitionList);

  // Outer‐query filter based on the alias
  const outerFilter = location
    ? `WHERE PartitionNameFriendly = @location`
    : `WHERE PartitionNameFriendly IN (${quoteList([
        'Pune','Quezon City','JP.Tokyo','MY.Kuala Lumpur','Taguig City','IN.HYD','SG.Singapore'      ])})`;

  const query = `
    WITH Hist AS (
      SELECT
        DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
        t1.ObjectName1,
        t1.ObjectName2               AS Door,
        CASE WHEN t2.Int1 = 0 THEN t2.Text12 ELSE CAST(t2.Int1 AS NVARCHAR) END AS EmployeeID,
        t3.Name                      AS PersonnelType,
        t1.ObjectIdentity1           AS PersonGUID,
t2.Text4                   AS CompanyName,
t2.Text5                   AS PrimaryLocation, 

 -- **Single** friendly‐name alias, with fallback
        COALESCE(
          CASE
            WHEN t1.ObjectName2 LIKE 'APAC_PI%'   THEN 'Taguig City'
            WHEN t1.ObjectName2 LIKE 'APAC_PH%'   THEN 'Quezon City'
            WHEN t1.ObjectName2 LIKE '%PUN%'      THEN 'Pune'
            WHEN t1.ObjectName2 LIKE 'APAC_JPN%'  THEN 'JP.Tokyo'
            WHEN t1.ObjectName2 LIKE 'APAC_MY%'   THEN 'MY.Kuala Lumpur'
             WHEN t1.ObjectName2 LIKE 'APAC_HYD%'   THEN 'IN.HYD'
             WHEN t1.ObjectName2 LIKE 'SG.Singapore%'  THEN 'SG.Singapore'

            ELSE t1.PartitionName2
          END,
          'APAC.Default'
        )                             AS PartitionNameFriendly,

        -- extract CardNumber
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
          sc.value
        )                            AS CardNumber,
        t5d.value                    AS Direction
      FROM ACVSUJournal_00010030.dbo.ACVSUJournalLog t1
      JOIN ACVSCore.Access.Personnel       t2 ON t1.ObjectIdentity1 = t2.GUID
      JOIN ACVSCore.Access.PersonnelType   t3 ON t2.PersonnelTypeID = t3.ObjectID
      LEFT JOIN ACVSUJournal_00010030.dbo.ACVSUJournalLogxmlShred t5d
        ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
      LEFT JOIN ACVSUJournal_00010030.dbo.ACVSUJournalLogxml t_xml
        ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, value
        FROM ACVSUJournal_00010030.dbo.ACVSUJournalLogxmlShred
        WHERE Name IN ('Card','CHUID')
      ) AS sc
        ON t1.XmlGUID = sc.GUID
      WHERE
        t1.MessageType = 'CardAdmitted'
        -- date filter remains here
        AND CONVERT(DATE, DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC))
            >= DATEADD(DAY, -${days}, CONVERT(DATE, GETDATE()))
    )

    -- now filter by the newly‐defined alias
    SELECT *
    FROM Hist
    ${outerFilter}
    ORDER BY LocaleMessageTime ASC;
  `;

  const req = pool.request();
  if (location) {
    req.input('location', sql.NVarChar, location);
  }
  const result = await req.query(query);
  return result.recordset;
};


exports.fetchHistoricalOccupancy = async (location) =>
  exports.fetchHistoricalData({ days: 15, location: location || null });



















// src/controllers/occupancy.controller.js
const service = require('../services/occupancy.service');

const {
  doorMap,
  normalizedDoorZoneMap,
  doorZoneMap,
  zoneFloorMap,
  normalizeDoorName
} = require('../utils/doorMap');


function isEmployeeType(pt) {
  return ['Employee','Terminated Employee','Terminated Personnel'].includes(pt);
}

/**
 * Resolve floor for a given partition + raw door + direction.
 * - Uses normalizedDoorZoneMap first -> zoneFloorMap lookup
 * - Falls back to per-partition doorMap entries
 * - If nothing matches, records to `unmapped` and returns 'Unknown'
 */
function lookupFloor(partition, rawDoor, direction, unmapped) {
  const norm = normalizeDoorName(rawDoor);
  const key  = `${norm}___${direction}`;

  // 1) Try normalized lookup
  const zone = normalizedDoorZoneMap[key];
  if (zone) {
    const f = zoneFloorMap[zone];
    // if zone has a known floor -> return it
    if (f) return f;
    // zone exists but has no floor (e.g. "Out of office") -> treat as known but Unknown floor
    // return immediately to avoid falling back to per-partition doorMap and marking as unmapped
    return 'Unknown';
  }

  // 2) Fallback to per-partition doorMap
  const entry = doorMap.find(d =>
    d.normalizedDoor === norm && d.partition === partition
  );
  if (entry) {
    const fl = direction === 'InDirection'
      ? entry.inDirectionFloor
      : entry.outDirectionFloor;
    if (fl) return fl;
  }

  // 3) Nothing matched → record & return Unknown
  unmapped.add(`${partition}|${rawDoor}`);
  return 'Unknown';
}


/**
 * Resolve a human-friendly Zone for a door+direction.
 * Returns:
 *  - actual zone string (e.g. 'Tower B', 'Yellow Zone', 'Reception Area', ...)
 *  - 'Unknown Zone' when nothing maps
 *  - retains 'Out of office' when mapped
 *
 * For OutDirection we remove trailing " Zone" when appropriate (but keep "Out of office" as-is).
 */
function mapDoorToZone(rawDoor, rawDir) {
  const key = normalizeDoorName(rawDoor) + '___' + (rawDir === 'InDirection' ? 'InDirection' : 'OutDirection');
  const zone = normalizedDoorZoneMap[key];
  if (!zone) return 'Unknown Zone';
  // for OutDirection that aren’t true “Out of office”, strip trailing “ Zone”
  if (rawDir === 'OutDirection' && zone !== 'Out of office') {
    return zone.replace(/\s+Zone$/i, '');
  }
  return zone;
}



exports.getLiveOccupancy = async (req,res) => {
  try {
    const data = await service.fetchLiveOccupancy();
    res.json({ success:true, count:data.length, data });
  } catch(e) {
    console.error(e);
    res.status(500).json({ success:false, message:'Live fetch failed' });
  }
};



exports.getLiveSummary = async (req,res) => {
  try {
    const swipes = await service.fetchLiveOccupancy();

    // first swipe per person = TODAY (dedupe to first swipe)
    const first = {};
    swipes.forEach(r => {
      const t = new Date(r.LocaleMessageTime).getTime();
      if (!first[r.PersonGUID] || t < new Date(first[r.PersonGUID].LocaleMessageTime).getTime()) {
        first[r.PersonGUID] = r;
      }
    });
    const today = { total:0, Employee:0, Contractor:0 };
    Object.values(first).forEach(r => {
      today.total++;
      if (isEmployeeType(r.PersonnelType)) today.Employee++;
      else today.Contractor++;
    });

    // last swipe per person for realtime (dedupe to last swipe)
    const last = {};
    swipes.forEach(r => {
      const t = new Date(r.LocaleMessageTime).getTime();
      if (!last[r.PersonGUID] || t > new Date(last[r.PersonGUID].LocaleMessageTime).getTime()) {
        last[r.PersonGUID] = r;
      }
    });

    const realtime = {};
    const unmapped = new Set();

    // Build enriched details (add Zone & Floor) for every last-swipe record
    // Keep Unknown Zone as null, keep actual zone strings (including "Out of office").
    const enriched = Object.values(last).map(r => {
      // determine zone (try normalized lookup + fallback)
      const zone = mapDoorToZone(r.Door, r.Direction);

      // lookupFloor returns 'Unknown' for unmapped (and adds to unmapped set)
      const floor = lookupFloor(r.PartitionName2, r.Door, r.Direction, unmapped);

      return {
        ...r,
        // null for unknown zone (makes filtering explicit), keep "Out of office" literal
        Zone: zone === 'Unknown Zone' ? null : zone,
        // convert server-side 'Unknown' -> null so client clearly sees "no floor"
        Floor: floor === 'Unknown' ? null : floor
      };
    });

    // Strictly remove "Out of office" records from details (and from counting below)
    // This ensures any door mapped to "Out of office" is NOT counted anywhere.
    const details = enriched.filter(r => r.Zone !== 'Out of office');

    // ---- Counting loop: use 'details' as the single source of truth ----
    // This prevents divergence between the details view and realtime totals.
    details.forEach(r => {
      // skip unknown/ unmapped zones entirely (they were converted to null)
      if (!r.Zone) return;

      const p = r.PartitionName2 || 'UnknownPartition';

      // ensure bucket
      if (!realtime[p]) realtime[p] = { total:0, Employee:0, Contractor:0, floors:{}, zones:{} };

      // increment totals
      realtime[p].total++;
      if (isEmployeeType(r.PersonnelType)) realtime[p].Employee++;
      else                                  realtime[p].Contractor++;

      // floor bucket: prefer server-computed Floor, otherwise attempt lookupFloor fallback
      let fl = r.Floor;
      if (!fl) {
        const maybe = lookupFloor(p, r.Door, r.Direction, unmapped);
        fl = maybe === 'Unknown' ? null : maybe;
      }
      if (fl) {
        realtime[p].floors[fl] = (realtime[p].floors[fl] || 0) + 1;
      }

      // zone bucket: for OutDirection we already stripped trailing " Zone" in mapDoorToZone,
      // and we have filtered out "Out of office" earlier, so safe to count the zone string.
      const z = r.Zone;
      if (z) {
        realtime[p].zones[z] = (realtime[p].zones[z] || 0) + 1;
      }
    });

    // Log to server console for quick dev feedback:
    if (unmapped.size) console.warn('Unmapped doors:', Array.from(unmapped));

    res.json({
      success:    true,
      today,
      realtime,
      // expose the raw list of partition|door keys that had no mapping:
      unmapped:   Array.from(unmapped),
      details    // enriched details with Zone & Floor, "Out of office" removed
    });

  } catch (e) {
    console.error(e);
    res.status(500).json({ success:false, message:'Summary failed' });
  }
};




// Historical occupancy (unchanged logic, kept here for completeness)
exports.getHistoricalOccupancy = async (req, res) => {
  const location = req.params.location || null;
  try {
    // 1) Pull in rows — each now has non-null PartitionNameFriendly
    const raw = await service.fetchHistoricalOccupancy(location);

    // 2) Dedupe to first swipe per person per day
    const byDate = raw.reduce((acc, r) => {
      // force into a "YYYY-MM-DD" string
      const date = new Date(r.LocaleMessageTime).toISOString().slice(0, 10);
      acc[date] = acc[date] || {};
      if (
        !acc[date][r.PersonGUID] ||
        new Date(r.LocaleMessageTime) < new Date(acc[date][r.PersonGUID].LocaleMessageTime)
      ) {
        acc[date][r.PersonGUID] = r;
      }
      return acc;
    }, {});

    const summaryByDate = [];
    const details = [];

    // 3) Build summaries
    Object.keys(byDate).sort().forEach(date => {
      const recs = Object.values(byDate[date]);
      details.push(...recs);

      // region totals
      const region = { total: 0, Employee: 0, Contractor: 0 };
      // per-partition buckets
      const partitions = {};

      recs.forEach(r => {
        // increment region
        region.total++;
        if (isEmployeeType(r.PersonnelType)) region.Employee++;
        else region.Contractor++;

        // only build partitions if we're not filtering to a single location
        if (!location) {
          // use the friendly name (guaranteed non-null!), with fallback
          const key = r.PartitionNameFriendly || 'APAC.Default';
          if (!partitions[key]) {
            partitions[key] = { total: 0, Employee: 0, Contractor: 0 };
          }
          partitions[key].total++;
          if (isEmployeeType(r.PersonnelType)) partitions[key].Employee++;
          else partitions[key].Contractor++;
        }
      });

      summaryByDate.push({
        date,
        day: new Date(date).toLocaleDateString('en-US', { weekday: 'long' }),
        region: location
          ? { name: location, ...region }
          : { name: 'APAC', ...region },
        partitions: location ? {} : partitions
      });
    });

    // 4) Return
    res.json({ success: true, summaryByDate, details });
  } catch (e) {
    console.error(e);
    res.status(500).json({ success: false, message: 'Historical failed' });
  }
};








