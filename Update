


// C:\Users\W0024618\Desktop\swipeData\employee-ai-insights\config\db.js

const sql    = require('mssql');
const dotenv = require('dotenv');
dotenv.config();

const config = {
  server:   process.env.DB_SERVER,
  user:     process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_DATABASE,
  connectionTimeout: 30000,    // 30 s to establish
  requestTimeout:    0,        // no timeout on individual queries
  pool: {
    max:                  100,
    min:                   0,

    // Use maximum 32-bit signed‚Äêint (~24.8 days) so Node/tarn doesn't overflow
    idleTimeoutMillis:    2147483647,
    acquireTimeoutMillis: 2147483647
  },
  options: {
    encrypt:               true,
    trustServerCertificate: true
  }
};

let poolPromise = null;

async function getPool(attempts = 10) {
  if (poolPromise) return poolPromise;

  poolPromise = (async () => {
    try {
      const pool = await sql.connect(config);
      console.log('‚úÖ MSSQL pool connected');

      // attach pool-level error listener so we can reset and attempt reconnects
      pool.on('error', err => {
        console.error('‚ùå MSSQL pool error:', err);
        // Reset promise so next getPool() tries to reconnect
        poolPromise = null;
      });

      return pool;
    } catch (err) {
      console.error('‚ùå MSSQL pool connection failed:', err);
      poolPromise = null;
      if (attempts > 0) {
        console.log(`‚è≥ Retrying MSSQL connect (${attempts} left)‚Ä¶`);
        await new Promise(res => setTimeout(res, 3000));
        return getPool(attempts - 1);
      }
      throw err;
    }
  })();

  // Global sql error: log but do not crash the process
  sql.on('error', err => {
    console.error('‚ùå MSSQL global error:', err);
    // Consider resetting poolPromise only for fatal errors:
    // poolPromise = null;
  });

  return poolPromise;
}

// Keep‚Äêalive ping every 5 minutes
setInterval(async () => {
  try {
    const pool = await getPool();
    await pool.request().query('SELECT 1');
    // console.log('üîÑ MSSQL keep‚Äêalive succeeded');
  } catch (err) {
    console.error('‚ö†Ô∏è MSSQL keep‚Äêalive ping failed:', err);
    // poolPromise stays intact so we keep using the same pool
  }
}, 5 * 60 * 1000);

module.exports = { sql, getPool };




88888888888888888888888888888888888888888888888888888888888888888






// config/siteConfig.js
const { sql, getPool } = require('./db');

// Pune uses the shared getPool():
const punePoolPromise = getPool();

// Denver pool configuration
const denverConfig = {
  user:     'GSOC_Test',
  password: 'Westernccure@2025',
  server:   'SRVWUDEN0891V',
  database: 'ACVSUJournal_00010028',
  options: {
    encrypt:               true,
    trustServerCertificate: true
  },
  pool: {
    max:                  5,
    min:                  0,

    // Make these extremely large so that Tarn will never time us out
    idleTimeoutMillis:    2147483647,
    acquireTimeoutMillis: 2147483647
  },
  connectionTimeout: 30000,  // 30 seconds to establish
  requestTimeout:    0       // no timeout on individual queries
};

let denverPoolPromise = null;

async function getDenverPool(attempts = 3) {
  // If a pool promise is already in-flight (or resolved), return it.
  if (denverPoolPromise) {
    return denverPoolPromise;
  }

  denverPoolPromise = (async () => {
    const pool = new sql.ConnectionPool(denverConfig);

    // If this pool ever errors, reset the promise so that
    // next time we can try to re-connect.
    pool.on('error', err => {
      console.error('‚ùå Denver MSSQL pool error:', err);
      denverPoolPromise = null;
    });

    try {
      await pool.connect();
      console.log('‚úÖ Denver MSSQL pool connected');
      return pool;
    } catch (err) {
      console.error('‚ùå Denver pool connection failed:', err);
      denverPoolPromise = null;

      if (attempts > 0) {
        console.log(`‚è≥ Retrying Denver pool connect (${attempts} left)‚Ä¶`);
        await new Promise(res => setTimeout(res, 3000));
        return getDenverPool(attempts - 1);
      }

      // If all retries fail, re¬≠throw so that calling code can catch it.
      throw err;
    }
  })().catch(err => {
    // Catch any unhandled rejection here so it never propagates
    // out of the immediate getDenverPool() call.
    console.error('‚ùå Denver pool promise ultimately failed:', err);
    denverPoolPromise = null;
    return null;
  });

  return denverPoolPromise;
}

// Every 5 minutes, ping Denver so it never goes idle.
// If ping fails, reset the poolPromise (so next request will re-connect).
setInterval(async () => {
  try {
    const pool = await getDenverPool();
    if (pool) {
      await pool.request().query('SELECT 1');
      // console.log('üîÑ Denver keep-alive succeeded');
    }
  } catch (err) {
    console.error('‚ö†Ô∏è Denver keep-alive failed, resetting poolPromise:', err);
    denverPoolPromise = null;
  }
}, 5 * 60 * 1000);

module.exports = {
  pune: {
    name:        'Pune',
    poolPromise: punePoolPromise,
    sql
  },
  denver: {
    name:        'Denver',
    poolPromise: getDenverPool(),
    sql
  }
};

