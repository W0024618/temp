Get-NetTCPConnection -LocalPort 3010 | Format-Table -AutoSize



// C:\... \controllers\liveOccupancyController.js
const { DateTime }   = require('luxon');
// const { poolConnect, pool, sql } = require('../config/db');
const { sql, getPool } = require('../config/db');

const doorZoneMap    = require('../data/doorZoneMap');
const zoneFloorMap   = require('../data/zoneFloorMap');

const ertMembers = require('../data/puneErtMembers.json');

// track which door→zone keys we've already warned on
const warnedKeys = new Set();

//update
function getTodayString() {
  return DateTime.now()
    .setZone('Asia/Kolkata')
    .toFormat('yyyy-LL-dd');
}

function normalizeZoneKey(rawDoor, rawDir) {
  let door = String(rawDoor || '').trim();
  door = door.replace(/_[0-9A-F]{2}:[0-9A-F]{2}:[0-9A-F]{2}$/, '');
  door = door.replace(/\s+/g, ' ').toUpperCase();
  const dir = rawDir === 'InDirection' ? 'InDirection' : 'OutDirection';
  return `${door}___${dir}`;
}

/** Normalize "Last, First" or "First Last" → lowercase "first last" */
function normalizePersonName(raw) {
  let n = String(raw || '').trim();
  if (n.includes(',')) {
    const [last, rest] = n.split(',', 2);
    n = `${rest.trim()} ${last.trim()}`;
  }
  return n.toLowerCase();
}

function mapDoorToZone(rawDoor, rawDir) {
  const key = normalizeZoneKey(rawDoor, rawDir);
  const zone = doorZoneMap[key];

  if (!zone) {
    if (!warnedKeys.has(key)) {
      console.warn('⛔ Unmapped door–direction key:', key);
      warnedKeys.add(key);
    }
    return 'Unknown Zone';
  }
  return zone;
}

/**
 * Fetch new events since a JS Date `since`.
 * Normalize record fields (LocaleMessageTime as JS Date, Dateonly, Swipe_Time).
 */
async function fetchNewEvents(since) {
  const pool = await getPool();
  const req  = pool.request();
  req.input('since', sql.DateTime2, since);

  const { recordset } = await req.query(`
    WITH CombinedQuery AS (
      SELECT
       DATEADD(MINUTE,-1 *t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
        t1.ObjectName1,
        CASE
          WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END AS EmployeeID,
        t1.ObjectIdentity1 AS PersonGUID,
        t3.Name AS PersonnelType,
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
          sc.value
        ) AS CardNumber,
        t5a.value AS AdmitCode,
        t5d.value AS Direction,
        t1.ObjectName2 AS Door,
        t1.ObjectName2 AS RawDoor,
        t1.MessageLocaleOffset
      FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLog] t1
      LEFT JOIN [ACVSCore].[Access].[Personnel]     t2 ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN [ACVSCore].[Access].[PersonnelType] t3 ON t2.PersonnelTypeId = t3.ObjectID
      LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5a
        ON t1.XmlGUID = t5a.GUID AND t5a.Name = 'AdmitCode'
      LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5d
        ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
      LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxml] t_xml
        ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, value
        FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred]
        WHERE Name IN ('Card','CHUID')
      ) sc ON t1.XmlGUID = sc.GUID
      WHERE
        t1.MessageType     = 'CardAdmitted'
        AND t1.PartitionName2 = 'APAC.Default'
        AND DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) > @since
    )
    SELECT
      LocaleMessageTime,
      CONVERT(VARCHAR(10), LocaleMessageTime, 23) AS Dateonly,
      CONVERT(VARCHAR(8) , LocaleMessageTime, 108) AS Swipe_Time,
      EmployeeID,
      PersonGUID,
      ObjectName1,
      PersonnelType,
      CardNumber,
      AdmitCode,
      Direction,
      Door
    FROM CombinedQuery
    ORDER BY LocaleMessageTime ASC;
  `);

  // Normalize each row: ensure LocaleMessageTime is a JS Date, and add consistent fields
  const normalized = (recordset || []).map(r => {
    // mssql usually returns Date objects for datetime columns; if it's a string, convert
    let localeDt = r.LocaleMessageTime;
    if (!localeDt) localeDt = new Date();
    else if (typeof localeDt === 'string') localeDt = new Date(localeDt);

    // Create Pune-local Dateonly/Swipe_Time using Luxon
    const local = DateTime.fromJSDate(localeDt, { zone: 'utc' }).setZone('Asia/Kolkata');
    return {
      ...r,
      LocaleMessageTime: localeDt,
      Dateonly: local.toFormat('yyyy-LL-dd'),
      Swipe_Time: local.toFormat('HH:mm:ss')
    };
  });

  return normalized;
}

async function buildOccupancy(allEvents) {
  const current      = {};
  const uniquePeople = new Map();

  for (const evt of allEvents) {
    const {
      EmployeeID, PersonGUID,
      ObjectName1, PersonnelType,
      CardNumber, Dateonly,
      Swipe_Time, Direction, Door
    } = evt;

    const dedupKey = PersonGUID || EmployeeID || CardNumber || ObjectName1;
    const zoneRaw  = mapDoorToZone(Door, Direction);

    if (zoneRaw === 'Unknown Zone') {
      continue;
    }

    const zoneLower = zoneRaw.toLowerCase();

    if (Direction === 'OutDirection') {
      if (zoneLower === 'out of office') {
        uniquePeople.delete(dedupKey);
        delete current[dedupKey];
      } else {
        uniquePeople.set(dedupKey, PersonnelType);
        current[dedupKey] = {
          Dateonly, Swipe_Time,
          EmployeeID, ObjectName1, CardNumber,
          PersonnelType,
          zone: zoneRaw,
          door: Door,
          Direction
        };
      }
      continue;
    }

    if (Direction === 'InDirection') {
      uniquePeople.set(dedupKey, PersonnelType);
      current[dedupKey] = {
        Dateonly, Swipe_Time,
        EmployeeID, ObjectName1, CardNumber,
        PersonnelType,
        zone: zoneRaw,
        door: Door,
        Direction
      };
      continue;
    }

    uniquePeople.delete(dedupKey);
    delete current[dedupKey];
  }

  let employeeCount   = 0;
  let contractorCount = 0;
  for (const pt of uniquePeople.values()) {
    if (['Employee','Terminated Personnel'].includes(pt)) employeeCount++;
    else contractorCount++;
  }

  const zoneMap = {};
  for (const emp of Object.values(current)) {
    const zKey = emp.zone.toLowerCase();
    if (zKey === 'out of office') continue;
    zoneMap[emp.zone] = zoneMap[emp.zone] || [];
    zoneMap[emp.zone].push(emp);
  }

  const zoneDetails = Object.fromEntries(
    Object.entries(zoneMap).map(([zone, emps]) => {
      const byType = emps.reduce((acc, e) => {
        acc[e.PersonnelType] = (acc[e.PersonnelType]||0) + 1;
        return acc;
      }, {});
      return [ zone, { total: emps.length, byPersonnelType: byType, employees: emps } ];
    })
  );

  const floorMap = {};
  for (const [zone, data] of Object.entries(zoneDetails)) {
    const floor = zoneFloorMap[zone] || 'Unknown Floor';
    floorMap[floor] = floorMap[floor] || { total: 0, byPersonnelType: {} };
    floorMap[floor].total += data.total;
    for (const [pt, c] of Object.entries(data.byPersonnelType)) {
      floorMap[floor].byPersonnelType[pt] = (floorMap[floor].byPersonnelType[pt]||0) + c;
    }
  }

  const ertStatus = Object.fromEntries(
    Object.entries(ertMembers).map(([role, members]) => {
      const list = members.map(m => {
        const rawName = m.name || m.Name;
        const expected = normalizePersonName(rawName);

        const matchEvt = Object.values(current).find(e => {
          return normalizePersonName(e.ObjectName1) === expected;
        });
        return {
          ...m,
          present: !!matchEvt,
          zone:    matchEvt ? matchEvt.zone : null
        };
     });
      return [ role, list ];
    })
  );

  return {
    asOf:             new Date().toISOString(),
    summary:          Object.entries(zoneDetails).map(([z,d])=>({ zone: z, count: d.total })),
    zoneBreakdown:    Object.entries(zoneDetails).map(([z,d])=>({ zone: z, ...d.byPersonnelType, total: d.total })),
    floorBreakdown:   Object.entries(floorMap).map(([f,d])=>({ floor: f, ...d.byPersonnelType, total: d.total })),
    details:          zoneMap,
    personnelSummary: { employees: employeeCount, contractors: contractorCount },
    ertStatus,
    personnelBreakdown: (() => {
      const map = new Map();
      for (const pt of uniquePeople.values()) {
        map.set(pt, (map.get(pt) || 0) + 1);
      }
      return Array.from(map, ([personnelType, count]) => ({ personnelType, count }));
    })(),
  };
}

/**
 * Build “visited today” from the same in‐memory stream
 */
function buildVisitedToday(allEvents, asOf) {
  let today;
  if (asOf) {
    if (typeof asOf === 'string') {
      today = asOf;
    } else if (asOf instanceof Date) {
      today = DateTime.fromJSDate(asOf, { zone: 'Asia/Kolkata' }).toFormat('yyyy-LL-dd');
    } else if (asOf && typeof asOf.toFormat === 'function') {
      today = asOf.setZone('Asia/Kolkata').toFormat('yyyy-LL-dd');
    } else {
      today = DateTime.now().setZone('Asia/Kolkata').toFormat('yyyy-LL-dd');
    }
  } else {
    today = DateTime.now().setZone('Asia/Kolkata').toFormat('yyyy-LL-dd');
  }

  const todayIns = allEvents.filter(evt => {
    return (
      evt.Direction === 'InDirection' &&
      evt.Dateonly === today
    );
  });

  const dedup = new Map();
  for (const e of todayIns) {
    const key = e.PersonGUID;
    const prev = dedup.get(key);
    if (!prev || String(e.LocaleMessageTime) > String(prev.LocaleMessageTime)) {
      dedup.set(key, e);
    }
  }

  const finalList = Array.from(dedup.values());

  const employees = finalList.filter(e =>
    !['Contractor','Terminated Contractor','Temp Badge','Visitor','Property Management']
      .includes(e.PersonnelType)
  ).length;
  const contractors = finalList.length - employees;

  return { employees, contractors, total: finalList.length };
}


/** Server‐Sent‐Events endpoint */
exports.getLiveOccupancy = async (req, res) => {
  try {
    await getPool();

    res.writeHead(200, {
      'Content-Type':  'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection':    'keep-alive'
    });
    res.write('\n');

    // IMPORTANT: start 24h back so dashboard shows recent data on initial connect
    let lastSeen = new Date(Date.now() - 24 * 60 * 60 * 1000);
    const events = [];

    const push = async () => {
      // prune events that aren't today (Kolkata) — keep only today's events
      const todayKolkata = DateTime.now().setZone('Asia/Kolkata').toISODate();
      for (let i = events.length - 1; i >= 0; i--) {
        const ts = DateTime.fromJSDate(events[i].LocaleMessageTime, { zone: 'utc' })
                       .setZone('Asia/Kolkata')
                       .toISODate();
        if (ts !== todayKolkata) {
          events.splice(i, 1);
        }
      }

      const fresh = await fetchNewEvents(lastSeen);

      if (fresh.length) {
        // append fresh events
        events.push(...fresh);

        // set lastSeen to the latest fetched event LocaleMessageTime to avoid duplicates or gaps
        const lastEvent = fresh[fresh.length - 1];
        lastSeen = new Date(lastEvent.LocaleMessageTime);
      }

      // build occupancy + today counts
      const occupancy  = await buildOccupancy(events);
      const todayStats = buildVisitedToday(events);

      occupancy.totalVisitedToday = todayStats.total;
      occupancy.visitedToday      = {
        employees:   todayStats.employees,
        contractors: todayStats.contractors,
        total:       todayStats.total
      };

      // ensure id so client treats as new
      const sid = Date.now();
      res.write(`id: ${sid}\n`);
      res.write(`data: ${JSON.stringify(occupancy)}\n\n`);

      if (typeof res.flush === 'function') {
        res.flush();
      }
    };

    // first push immediately (fetches last 24h because of lastSeen)
    await push();
    const timer = setInterval(push, 2000);
    req.on('close', () => {
      clearInterval(timer);
    });

  } catch (err) {
    console.error('Live occupancy SSE error:', err && (err.stack || err));
    if (!res.headersSent) {
      res.status(500).json({ error: 'Internal Server Error' });
    }
  }
};

// The rest of this file (snapshots/monthly summary) is unchanged from what you had previously.
// ... (kept intentionally) ...















// src/App.js
import React, {
  useEffect,
  useState,
  useRef,
  useCallback,
  lazy,
  Suspense
} from 'react';
import {
  Container,
  Navbar,
  Nav,
  Button,
  InputGroup,
  FormControl,
  Spinner
} from 'react-bootstrap';
import { BrowserRouter, Routes, Route, Link, useLocation } from 'react-router-dom';
import { FaSun } from 'react-icons/fa';

import './App.css';
import './api.js';

// Lazy-loaded pages
const DashboardHome = lazy(() => import('./pages/DashboardHome'));
const ErtPage = lazy(() => import('./pages/ErtPage'));
const ZoneDetailsTable = lazy(() => import('./components/ZoneDetailsTable'));

function TimeTravelControl({ currentTimestamp, onApply, onLive, loading }) {
  const [local, setLocal] = useState(currentTimestamp ? isoToInput(currentTimestamp) : '');

  useEffect(() => {
    if (currentTimestamp) setLocal(isoToInput(currentTimestamp));
    else setLocal('');
  }, [currentTimestamp]);

  const handleApply = useCallback(() => {
    if (!local) return;
    const selected = new Date(local);
    const now = new Date();
    if (selected > now) {
      window.alert("Please select a relevant time — snapshot cannot be in the future");
      return;
    }
    const [datePart, timePart] = local.split('T');
    onApply(datePart, timePart);
  }, [local, onApply]);

  const handleLive = useCallback(() => {
    setLocal('');
    onLive();
  }, [onLive]);

  return (
    <div style={{ display: 'flex', gap: 8, alignItems: 'center', minWidth: 340 }}>
      <InputGroup>
        <FormControl
          type="datetime-local"
          value={local}
          onChange={(e) => setLocal(e.target.value)}
          placeholder="Select date & time"
        />
      </InputGroup>

      <div style={{ display: 'flex', gap: 6 }}>
        <Button variant="outline-warning" onClick={handleApply} disabled={loading || !local}>
          {loading ? <><Spinner animation="border" size="sm" />&nbsp;Applying</> : 'Apply'}
        </Button>
        <Button variant="warning" onClick={handleLive} disabled={loading}>
          Live
        </Button>
      </div>
    </div>
  );
}

function pad(n) { return String(n).padStart(2, '0'); }
function isoToInput(iso) {
  if (!iso) return '';
  const d = new Date(iso);
  return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}`;
}

const ZoneDetailsPage = React.memo(function ZoneDetailsPage({ detailsData }) {
  const [searchTerm, setSearchTerm] = useState('');

  return (
    <>
      <div
        className="d-flex justify-content-between align-items-center mb-2"
        style={{ flexWrap: 'wrap', gap: '0.5rem' }}
      >
        <Link to="/" className="btn btn-secondary">← Back to Dashboard</Link>
        <input
          type="text"
          placeholder="Search employee..."
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          style={{
            flexGrow: 1,
            maxWidth: 300,
            padding: '0.4rem 0.8rem',
            fontSize: '1rem',
            borderRadius: 4,
            border: '1px solid #ccc'
          }}
        />
      </div>
      <Suspense fallback={<div>Loading details…</div>}>
        <ZoneDetailsTable data={detailsData} searchTerm={searchTerm} />
      </Suspense>
    </>
  );
});

function App() {
  const esRef = useRef(null);
  const sseBufferRef = useRef(null);
  const sseFlushScheduledRef = useRef(false);

  const location = useLocation();
  const headerText = location.pathname === '/ert'
    ? 'Emergency Response Team — Western Union Pune'
    : 'Live Occupancy — Western Union Pune';

  const API_BASE = (process.env.REACT_APP_API_BASE_URL)
    || (process.env.NODE_ENV === 'development' ? 'http://10.199.22.57:3010' : window.location.origin);
  const API_ORIGIN = API_BASE.replace(/\/$/, '');

  const [liveData, setLiveData] = useState({
    summary: [],
    details: {},
    floorBreakdown: [],
    zoneBreakdown: [],
    personnelBreakdown: [],
    totalVisitedToday: 0,
    personnelSummary: { employees: 0, contractors: 0 },
    visitedToday: { employees: 0, contractors: 0, total: 0 },
    ertStatus: {}
  });

  const [timeTravelMode, setTimeTravelMode] = useState(false);
  const [timeTravelTimestamp, setTimeTravelTimestamp] = useState(null);
  const [timeTravelLoading, setTimeTravelLoading] = useState(false);

  // SSE with throttling
  useEffect(() => {
    if (timeTravelMode) {
      if (esRef.current) esRef.current.close();
      esRef.current = null;
      return;
    }

    const esUrl = `${API_ORIGIN}/api/live-occupancy`;
    console.info('[SSE] connecting to', esUrl);
    const es = new EventSource(esUrl);
    esRef.current = es;

    es.onopen = () => {
      console.info('[SSE] connection opened');
    };

    es.onmessage = (e) => {
      try {
        const p = JSON.parse(e.data);
        sseBufferRef.current = p;

        if (!sseFlushScheduledRef.current) {
          sseFlushScheduledRef.current = true;
          setTimeout(() => {
            // Use setPayload so payload normalization is consistent with time-travel snapshots
            try {
              setPayload(sseBufferRef.current);
              console.info('[SSE] applied new payload (throttled)');
            } catch (err) {
              console.error('[SSE] error applying payload', err);
            } finally {
              sseFlushScheduledRef.current = false;
            }
          }, 500); // throttle updates to every 0.5s
        }
      } catch (err) {
        console.error('[SSE] parse error', err);
      }
    };

    es.onerror = (errEvent) => {
      console.error('[SSE] error connecting to', esUrl, errEvent);
      try { es.close(); } catch (e) {}
      esRef.current = null;
    };

    return () => {
      try { es.close(); } catch (e) {}
      esRef.current = null;
    };
  }, [timeTravelMode, API_ORIGIN]);

  // Unified payload setter (keep as you had, used by snapshots and SSE)
  const setPayload = useCallback((p) => {
    setLiveData({
      summary: Array.isArray(p.summary) ? p.summary : [],
      details: p.details || {},
      floorBreakdown: Array.isArray(p.floorBreakdown) ? p.floorBreakdown : (Array.isArray(p.floor) ? p.floor : []),
      zoneBreakdown: Array.isArray(p.zoneBreakdown) ? p.zoneBreakdown : [],
      personnelBreakdown: Array.isArray(p.personnelBreakdown) ? p.personnelBreakdown : [],
      totalVisitedToday: typeof p.totalVisitedToday === 'number' ? p.totalVisitedToday : (typeof p.totalVisitedToday === 'undefined' ? (p.visitedToday?.total || 0) : 0),
      personnelSummary: p.personnelSummary || { employees: 0, contractors: 0 },
      visitedToday: p.visitedToday || { employees: 0, contractors: 0, total: 0 },
      ertStatus: p.ertStatus || {}
    });
  }, []);

  // Fetch a historical snapshot
  const fetchSnapshot = useCallback(async (dateStr, timeStr) => {
    setTimeTravelLoading(true);
    const safeTime = timeStr.length === 5 ? `${timeStr}:00` : timeStr;
    const url = `${API_ORIGIN}/api/occupancy-at-time-pune?date=${encodeURIComponent(dateStr)}&time=${encodeURIComponent(safeTime)}`;

    try {
      const resp = await fetch(url, { method: 'GET', headers: { 'Accept': 'application/json' } });
      if (!resp.ok) {
        const body = await resp.text().catch(() => '');
        console.error(`[TimeTravel] error ${resp.status} from ${url}`, body);
        window.alert(`Failed to load snapshot (${resp.status}). See console for details.`);
        throw new Error(`Server returned ${resp.status}`);
      }

      const p = await resp.json();
      setPayload(p);
      setTimeTravelMode(true);
      setTimeTravelTimestamp(p?.asOfLocal || `${dateStr} ${safeTime}`);
    } catch (err) {
      console.error('Failed to fetch snapshot', err);
      if (!err.message.includes('Server returned')) {
        window.alert('Failed to load snapshot. See console for details.');
      }
    } finally {
      setTimeTravelLoading(false);
    }
  }, [API_ORIGIN, setPayload]);

  // Return to live mode
  const clearTimeTravel = useCallback(async () => {
    setTimeTravelLoading(true);
    try {
      setTimeTravelMode(false);
      setTimeTravelTimestamp(null);
      sseBufferRef.current = null;
    } finally {
      setTimeTravelLoading(false);
    }
  }, []);

  return (
    <>
      <Navbar bg="dark" variant="dark" expand="lg" className="px-3">
        <Navbar.Brand as={Link} to="/" className="wu-brand">
          {headerText}
        </Navbar.Brand>

        <Navbar.Toggle aria-controls="main-navbar" />
        <Navbar.Collapse id="main-navbar">
          <Nav className="ms-auto align-items-center gap-2">
            <div className="time-travel-wrapper me-2">
              <TimeTravelControl
                currentTimestamp={timeTravelTimestamp}
                onApply={fetchSnapshot}
                onLive={clearTimeTravel}
                loading={timeTravelLoading}
              />
            </div>

            <Nav.Link as={Link} to="/" className="nav-item-infographic">
              <i className="bi bi-house"></i>
            </Nav.Link>
            <Nav.Link href={`http://10.199.22.57:3000/partition/Pune/history`} className="nav-item-infographic">
              <i className="bi bi-clock-history"></i>
            </Nav.Link>
            <Nav.Link as={Link} to="/details" className="nav-item-infographic">
              <i className="fa-solid fa-calendar-day"></i>
            </Nav.Link>
            <Nav.Link as={Link} to="/ert" className="nav-item-infographic">
              ERT Overview
            </Nav.Link>
            <Nav.Link className="theme-toggle-icon" title="Dark mode only">
              <FaSun />
            </Nav.Link>
          </Nav>
        </Navbar.Collapse>
      </Navbar>

      <Container fluid className="mt-2">
        {timeTravelMode && (
          <div style={{
            background: '#434d44',
            color: '#FFF',
            padding: '8px 16px',
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            borderLeft: '4px solid rgb(0, 255, 21)',
            marginBottom: 8
          }}>
            <div>
              Viewing historical snapshot for:&nbsp;
              <strong>{new Date(timeTravelTimestamp).toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' })}</strong>
            </div>
            <div>
              <button
                className="btn btn-sm btn-outline-warning"
                onClick={clearTimeTravel}
                disabled={timeTravelLoading}
              >
                Return to Live
              </button>
            </div>
          </div>
        )}

        <Suspense fallback={<div style={{ color: '#FFC72C' }}>Loading page…</div>}>
          <Routes>
            <Route
              path="/"
              element={
                <DashboardHome
                  summaryData={liveData.summary}
                  detailsData={liveData.details}
                  floorData={liveData.floorBreakdown}
                  zoneBreakdown={liveData.zoneBreakdown}
                  personnelBreakdown={liveData.personnelBreakdown}
                  totalVisitedToday={liveData.totalVisitedToday}
                  personnelSummary={liveData.personnelSummary}
                  visitedToday={liveData.visitedToday}
                  ertStatus={liveData.ertStatus}
                />
              }
            />
            <Route path="/details" element={<ZoneDetailsPage detailsData={liveData.details} />} />
            <Route path="/ert" element={<ErtPage ertStatus={liveData.ertStatus} />} />
          </Routes>
        </Suspense>
      </Container>

      <style>{`
/* Brand text scales */
.wu-brand {
  font-size: clamp(1rem, 1.5vw, 1.4rem);
  white-space: normal;
}

/* Navbar link icons spacing */
.nav-item-infographic {
  font-size: 1.1rem;
  padding: 0.4rem;
}

.theme-toggle-icon {
  font-size: 1.25rem;
}

/* --- Breakpoints --- */

/* Mobile (<576px) */
@media (max-width: 575.98px) {
  .time-travel-wrapper {
    width: 100%;
    margin-bottom: 0.75rem;
  }
}

/* Tablet (≥576px and <992px) */
@media (min-width: 576px) and (max-width: 991.98px) {
  .time-travel-wrapper {
    flex: 1;
    min-width: 280px;
  }
}

/* Laptop & Desktop (≥992px) */
@media (min-width: 992px) {
  .time-travel-wrapper {
    min-width: 340px;
    margin-bottom: 0;
  }
}
      `}</style>
    </>
  );
}

export default function WrappedApp() {
  return (
    <BrowserRouter>
      <div className="dark-theme">
        <App />
      </div>
    </BrowserRouter>
  );
}
















Check below Backend and frontend file carefully 
Our issue is Frontend not render any data 
so debug each bakend and frontend file line by line and solve the issue carefully...

https://react.dev/link/react-devtools
App.js:315 [SSE] connecting to http://10.199.22.57:3010/api/live-occupancy
deprecations.ts:9 ⚠️ React Router Future Flag Warning: React Router will begin wrapping state updates in `React.startTransition` in v7. You can use the `v7_startTransition` future flag to opt-in early. For more information, see https://reactrouter.com/v6/upgrading/future#v7_starttransition.
deprecations.ts:9 ⚠️ React Router Future Flag Warning: Relative route resolution within Splat routes is changing in v7. You can use the `v7_relativeSplatPath` future flag to opt-in early. For more information, see https://reactrouter.com/v6/upgrading/future#v7_relativesplatpath.
App.js:315 [SSE] connecting to http://10.199.22.57:3010/api/live-occupancy
App.js:320 [SSE] connection opened
﻿

Ask AI about more insights
You can now ask Gemini about more performance insights: image delivery, legacy JavaScript, duplicate JavaScript, and modern HTTP.

Emulate the 'Save-Data' header
In 'Network conditions', you can now emulate the 'Save-Data' request header that indicates the client's preference for reduced data usage.

Debug complex CSS values easier
See also, from version 138: The Elements > Styles tab can now show you a tooltip with a breakdown of the definition chain and step-by-step evaluations of complex CSS variables, so you can find bugs quicker and gain a deeper understanding of how a value is computed.

alos in console there is no any error 


// C:\Users\W0024618\Desktop\swipeData\employee-ai-insights\controllers\liveOccupancyController.js


const { DateTime }   = require('luxon');
// const { poolConnect, pool, sql } = require('../config/db');
const { sql, getPool } = require('../config/db');

const doorZoneMap    = require('../data/doorZoneMap');
const zoneFloorMap   = require('../data/zoneFloorMap');

const ertMembers = require('../data/puneErtMembers.json');

// track which door→zone keys we've already warned on
const warnedKeys = new Set();

//update
function getTodayString() {
  return DateTime.now()
    .setZone('Asia/Kolkata')
    .toFormat('yyyy-LL-dd');
}




function normalizeZoneKey(rawDoor, rawDir) {
  // 1) Ensure it’s a string and trim whitespace
  let door = String(rawDoor || '').trim();

  // 2) Strip any "_HH:MM:SS" or "_XX:XX:XX" suffix (hex codes or times at end)
  door = door.replace(/_[0-9A-F]{2}:[0-9A-F]{2}:[0-9A-F]{2}$/, '');

  // 3) Collapse multiple spaces into one, then uppercase
  door = door.replace(/\s+/g, ' ').toUpperCase();

  // 4) Pick the direction token exactly as doorZoneMap expects
  const dir = rawDir === 'InDirection' ? 'InDirection' : 'OutDirection';

  return `${door}___${dir}`;
}

/** Normalize "Last, First" or "First Last" → lowercase "first last" */
function normalizePersonName(raw) {
  let n = String(raw || '').trim();
  if (n.includes(',')) {
    const [last, rest] = n.split(',', 2);
    n = `${rest.trim()} ${last.trim()}`;
  }
  return n.toLowerCase();
}


// --- new mapDoorToZone ---
function mapDoorToZone(rawDoor, rawDir) {
  const key = normalizeZoneKey(rawDoor, rawDir);
  const zone = doorZoneMap[key];

  if (!zone) {
    if (!warnedKeys.has(key)) {
      console.warn('⛔ Unmapped door–direction key:', key);
      warnedKeys.add(key);
    }
    return 'Unknown Zone';
  }

  // IMPORTANT: return the zone exactly as defined in doorZoneMap
  return zone;
}


async function fetchNewEvents(since) {
  // await the shared pool promise instead of poolConnect
  const pool = await getPool();
  const req  = pool.request();
  req.input('since', sql.DateTime2, since);

// console.log('🔎 [Pune] fetchNewEvents called with since =', since.toISOString());
  const { recordset } = await req.query(`
    WITH CombinedQuery AS (
      SELECT
       DATEADD(MINUTE,-1 *t1.MessageLocaleOffset, t1.MessageUTC) AS LocaleMessageTime,
       
        t1.ObjectName1,
        CASE
          WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END AS EmployeeID,
        t1.ObjectIdentity1 AS PersonGUID,
        t3.Name AS PersonnelType,
        COALESCE(
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
          TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
          sc.value
        ) AS CardNumber,
        t5a.value AS AdmitCode,
        t5d.value AS Direction,
        t1.ObjectName2 AS Door
      FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLog] t1
      LEFT JOIN [ACVSCore].[Access].[Personnel]     t2 ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN [ACVSCore].[Access].[PersonnelType] t3 ON t2.PersonnelTypeId = t3.ObjectID
      LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5a
        ON t1.XmlGUID = t5a.GUID AND t5a.Name = 'AdmitCode'
      LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5d
        ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
      LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxml] t_xml
        ON t1.XmlGUID = t_xml.GUID
      LEFT JOIN (
        SELECT GUID, value
        FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred]
        WHERE Name IN ('Card','CHUID')
      ) sc ON t1.XmlGUID = sc.GUID
      WHERE
        t1.MessageType     = 'CardAdmitted'
        AND t1.PartitionName2 = 'APAC.Default'
        AND DATEADD(MINUTE, -1 * t1.MessageLocaleOffset, t1.MessageUTC) >@since
    )
    SELECT
      LocaleMessageTime,
      CONVERT(VARCHAR(10), LocaleMessageTime, 23) AS Dateonly,
      CONVERT(VARCHAR(8) , LocaleMessageTime, 108) AS Swipe_Time,
      EmployeeID,
      PersonGUID,
      ObjectName1,
      PersonnelType,
      CardNumber,
      AdmitCode,
      Direction,
      Door
    FROM CombinedQuery
    ORDER BY LocaleMessageTime ASC;
  `);

  // console.log(`📥 [Pune] fetched ${recordset.length} rows:`,
    // recordset.map(r => r.LocaleMessageTime.toISOString()));

  return recordset;
}

async function buildOccupancy(allEvents) {
  const current      = {};
  const uniquePeople = new Map();
// --- simplified per-event loop inside buildOccupancy ---
for (const evt of allEvents) {
  const {
    EmployeeID, PersonGUID,
    ObjectName1, PersonnelType,
    CardNumber, Dateonly,
    Swipe_Time, Direction, Door
  } = evt;

  const dedupKey = PersonGUID || EmployeeID || CardNumber || ObjectName1;
  const zoneRaw  = mapDoorToZone(Door, Direction);

  // 1) If we can’t map door+direction to a valid zone, skip this event entirely.
  if (zoneRaw === 'Unknown Zone') {
    continue;
  }

  const zoneLower = zoneRaw.toLowerCase();

  // OutDirection: eviction only for the real "Out of office"
  if (Direction === 'OutDirection') {
    if (zoneLower === 'out of office') {
      uniquePeople.delete(dedupKey);
      delete current[dedupKey];
    } else {
      // Keep them in headcount, update last-seen
      uniquePeople.set(dedupKey, PersonnelType);
      current[dedupKey] = {
        Dateonly, Swipe_Time,
        EmployeeID, ObjectName1, CardNumber,
        PersonnelType,
        zone: zoneRaw,
        door: Door,
        Direction
      };
    }
    continue;
  }

  // InDirection → normal check-in
  if (Direction === 'InDirection') {
    uniquePeople.set(dedupKey, PersonnelType);
    current[dedupKey] = {
      Dateonly, Swipe_Time,
      EmployeeID, ObjectName1, CardNumber,
      PersonnelType,
      zone: zoneRaw,
      door: Door,
      Direction
    };
    continue;
  }
  // Catch-all eviction
  uniquePeople.delete(dedupKey);
  delete current[dedupKey];
}

// live headcounts (only from uniquePeople, which has already evicted all true out-of-office)
  let employeeCount   = 0;
  let contractorCount = 0;
  for (const pt of uniquePeople.values()) {
    if (['Employee','Terminated Personnel'].includes(pt)) employeeCount++;
    else contractorCount++;
  }

  // Build zone→people map, but filter out any out-of-office at this final step too
  const zoneMap = {};
  for (const emp of Object.values(current)) {
    const zKey = emp.zone.toLowerCase();
    if (zKey === 'out of office') continue;
    zoneMap[emp.zone] = zoneMap[emp.zone] || [];
    zoneMap[emp.zone].push(emp);
  }

  // zoneDetails
  const zoneDetails = Object.fromEntries(
    Object.entries(zoneMap).map(([zone, emps]) => {
      const byType = emps.reduce((acc, e) => {
        acc[e.PersonnelType] = (acc[e.PersonnelType]||0) + 1;
        return acc;
      }, {});
      return [ zone, { total: emps.length, byPersonnelType: byType, employees: emps } ];
    })
  );

  // floorBreakdown
  const floorMap = {};
  for (const [zone, data] of Object.entries(zoneDetails)) {
    const floor = zoneFloorMap[zone] || 'Unknown Floor';
    floorMap[floor] = floorMap[floor] || { total: 0, byPersonnelType: {} };
    floorMap[floor].total += data.total;
    for (const [pt, c] of Object.entries(data.byPersonnelType)) {
      floorMap[floor].byPersonnelType[pt] = (floorMap[floor].byPersonnelType[pt]||0) + c;
    }
  }


  const ertStatus = Object.fromEntries(
    Object.entries(ertMembers).map(([role, members]) => {
      const list = members.map(m => {
        // pick the correct name field (JSON uses "Name")
        const rawName = m.name || m.Name;
        const expected = normalizePersonName(rawName);

        // find a matching swipe in current[]
        const matchEvt = Object.values(current).find(e => {
          return normalizePersonName(e.ObjectName1) === expected;
        });
        return {
          ...m,
          present: !!matchEvt,
          zone:    matchEvt ? matchEvt.zone : null
        };
     });
      return [ role, list ];
    })
  );

  return {
    asOf:             new Date().toISOString(),
    summary:          Object.entries(zoneDetails).map(([z,d])=>({ zone: z, count: d.total })),
    zoneBreakdown:    Object.entries(zoneDetails).map(([z,d])=>({ zone: z, ...d.byPersonnelType, total: d.total })),
    floorBreakdown:   Object.entries(floorMap).map(([f,d])=>({ floor: f, ...d.byPersonnelType, total: d.total })),
    details:          zoneMap,
    personnelSummary: { employees: employeeCount, contractors: contractorCount },
     ertStatus,
  
  personnelBreakdown: (() => {
    const map = new Map();
    // uniquePeople: Map<dedupKey, PersonnelType>
    for (const pt of uniquePeople.values()) {
      map.set(pt, (map.get(pt) || 0) + 1);
    }
    return Array.from(map, ([personnelType, count]) => ({ personnelType, count }));
  })(),
  };
}


/**
 * Build “visited today” from the same in‐memory stream
 *
 * @param {Array} allEvents  - events where evt.Dateonly is already local yyyy-MM-dd
 * @param {DateTime|Date|string} [asOf] - optional Luxon DateTime, JS Date or yyyy-MM-dd string.
 *                                       If provided, "today" will be computed from this instead
 *                                       of DateTime.now().setZone('Asia/Kolkata').
 */
function buildVisitedToday(allEvents, asOf) {
  // Determine "today" in Asia/Kolkata:
  let today;
  if (asOf) { 
    // Accept Luxon DateTime, JS Date, or plain yyyy-MM-dd string
    if (typeof asOf === 'string') {
      today = asOf; // assume already 'yyyy-LL-dd'
    } else if (asOf instanceof Date) {
      today = DateTime.fromJSDate(asOf, { zone: 'Asia/Kolkata' }).toFormat('yyyy-LL-dd');
    } else if (asOf && typeof asOf.toFormat === 'function') {
      // assume Luxon DateTime
      today = asOf.setZone('Asia/Kolkata').toFormat('yyyy-LL-dd');
    } else {
      // fallback to now
      today = DateTime.now().setZone('Asia/Kolkata').toFormat('yyyy-LL-dd');
    }
  } else {
    // default behaviour: "today" is now in Kolkata
    today = DateTime.now().setZone('Asia/Kolkata').toFormat('yyyy-LL-dd');
  }

  // Use evt.Dateonly (already “yyyy-MM-dd” in local zone) to pick out today's InDirection swipes
  const todayIns = allEvents.filter(evt => {
    return (
      evt.Direction === 'InDirection' &&
      evt.Dateonly === today
    );
  });

  // Dedupe by PersonGUID → keep the latest swipe
  const dedup = new Map();
  for (const e of todayIns) {
    const key = e.PersonGUID; // same as original logic
    const prev = dedup.get(key);
    // Compare LocaleMessageTime lexicographically is fine for ISO strings; keep original behavior
    if (!prev || e.LocaleMessageTime > prev.LocaleMessageTime) {
      dedup.set(key, e);
    }
  }

  const finalList = Array.from(dedup.values());

  // Separate employees vs contractors (preserve original classification list)
  const employees = finalList.filter(e =>
    !['Contractor','Terminated Contractor','Temp Badge','Visitor','Property Management']
      .includes(e.PersonnelType)
  ).length;
  const contractors = finalList.length - employees;

  return { employees, contractors, total: finalList.length };
}



/** Server‐Sent‐Events endpoint */
exports.getLiveOccupancy = async (req, res) => {
  try {
    // wait for the shared pool to be ready
    await getPool();

    res.writeHead(200, {
      'Content-Type':  'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection':    'keep-alive'
    });
    res.write('\n');

    // pull last 24h on startup
    // let lastSeen = new Date(Date.now() - 24*60*60*1000);
    let lastSeen = new Date();
    const events = [];

    const push = async () => {

    // Option B: Recompute date from the JS timestamp in Asia/Kolkata:
    const todayKolkata = DateTime.now().setZone('Asia/Kolkata').toISODate();
    for (let i = events.length - 1; i >= 0; i--) {
      const ts = DateTime.fromJSDate(events[i].LocaleMessageTime, { zone: 'utc' })
                     .setZone('Asia/Kolkata')
                     .toISODate();
      if (ts !== todayKolkata) {
        events.splice(i, 1);
      }
    }


//  console.log('🔄 [PUSH] Running at:', new Date().toISOString());
  // console.log('🔍 Last seen swipe time:', lastSeen);


      const fresh = await fetchNewEvents(lastSeen);

      //  console.log('📥 New events fetched:', fresh.length);

      if (fresh.length) {
        // lastSeen = fresh[fresh.length - 1].LocaleMessageTime;
         lastSeen = new Date();
        events.push(...fresh);
      }

  
      // build occupancy + today counts
      const occupancy  = await buildOccupancy(events);
      const todayStats = buildVisitedToday(events);

      occupancy.totalVisitedToday = todayStats.total;
      occupancy.visitedToday      = {
        employees:   todayStats.employees,
        contractors: todayStats.contractors,
        total:       todayStats.total
      };

  

      // add an `id:` so EventSource treats even identical payloads as “new”
      
      const sid = Date.now();
      res.write(`id: ${sid}\n`);
      res.write(`data: ${JSON.stringify(occupancy)}\n\n`);

    
      if (typeof res.flush === 'function') {
        res.flush();
      }

     };
    await push();
    const timer = setInterval(push, 2000);
    req.on('close', () => clearInterval(timer));

  } catch (err) {
    console.error('Live occupancy SSE error:', err);
    if (!res.headersSent) {
      res.status(500).json({ error: 'Internal Server Error' });
    }
  }
};



// GET /api/occupancy-at-time-pune?date=YYYY-MM-DD&time=HH:MM[:SS]
exports.getPuneSnapshotAtDateTime = async (req, res) => {
  try {
    const { date, time } = req.query;
    if (!date || !time) {
      return res.status(400).json({
        error: 'missing query params: expected ?date=YYYY-MM-DD&time=HH:MM[:SS]'
      });
    }

    // Validate date
    const dateMatch = /^(\d{4})-(\d{2})-(\d{2})$/.exec(date);
    if (!dateMatch) {
      return res.status(400).json({ error: 'invalid "date" format; expected YYYY-MM-DD' });
    }

    // Validate time
    const timeMatch = /^([0-1]\d|2[0-3]):([0-5]\d)(?::([0-5]\d))?$/.exec(time);
    if (!timeMatch) {
      return res.status(400).json({ error: 'invalid "time" format; expected HH:MM or HH:MM:SS' });
    }

    const year   = Number(dateMatch[1]);
    const month  = Number(dateMatch[2]);
    const day    = Number(dateMatch[3]);
    const hour   = Number(timeMatch[1]);
    const minute = Number(timeMatch[2]);
    const second = timeMatch[3] ? Number(timeMatch[3]) : 0;

    // Build Pune-local datetime
    const atDt = DateTime.fromObject(
      { year, month, day, hour, minute, second, millisecond: 0 },
      { zone: 'Asia/Kolkata' }
    );

    if (!atDt.isValid) {
      return res.status(400).json({ error: 'invalid date+time combination' });
    }

    // Convert to UTC for SQL boundary
    const untilUtc = atDt.setZone('utc').toJSDate();

    // -----------------
    // Step 1: fetch events in 24h window ending at atDt
    const pool = await getPool();
    const reqDb = pool.request();
    reqDb.input('until', sql.DateTime2, untilUtc);

    const { recordset } = await reqDb.query(`
      WITH CombinedQuery AS (
        SELECT
          t1.MessageUTC,   -- always UTC
          t1.ObjectName1,
          CASE
            WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
            ELSE CAST(t2.Int1 AS NVARCHAR)
          END AS EmployeeID,
          t1.ObjectIdentity1 AS PersonGUID,
          t3.Name AS PersonnelType,
          COALESCE(
            TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID/Card)[1]','varchar(50)'),
            TRY_CAST(t_xml.XmlMessage AS XML).value('(/LogMessage/CHUID)[1]','varchar(50)'),
            sc.value
          ) AS CardNumber,
          t5a.value AS AdmitCode,
          t5d.value AS Direction,
          t1.ObjectName2 AS Door
        FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLog] t1
        LEFT JOIN [ACVSCore].[Access].[Personnel]     t2 ON t1.ObjectIdentity1 = t2.GUID
        LEFT JOIN [ACVSCore].[Access].[PersonnelType] t3 ON t2.PersonnelTypeId = t3.ObjectID
        LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5a
          ON t1.XmlGUID = t5a.GUID AND t5a.Name = 'AdmitCode'
        LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5d
          ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
        LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxml] t_xml
          ON t1.XmlGUID = t_xml.GUID
        LEFT JOIN (
          SELECT GUID, value
          FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred]
          WHERE Name IN ('Card','CHUID')
        ) sc ON t1.XmlGUID = sc.GUID
        WHERE
          t1.MessageType     = 'CardAdmitted'
          AND t1.PartitionName2 = 'APAC.Default'
          AND t1.MessageUTC <= @until
          AND DATEADD(HOUR, -24, @until) < t1.MessageUTC
      )
      SELECT *
      FROM CombinedQuery
      ORDER BY MessageUTC ASC;
    `);

    // -----------------
    // Step 2: convert UTC → Asia/Kolkata
    const events = recordset.map(e => {
      const local = DateTime.fromJSDate(e.MessageUTC, { zone: 'utc' })
                            .setZone('Asia/Kolkata');
      return {
        ...e,
        LocaleMessageTime: local.toISO(),
        Dateonly: local.toFormat('yyyy-LL-dd'),
        Swipe_Time: local.toFormat('HH:mm:ss'),
      };
    });

    // -----------------
    // Step 3: filter only same Pune date
    const targetDate = atDt.toFormat('yyyy-LL-dd');
    const filtered = events.filter(e => e.Dateonly === targetDate);

    // Step 4: build occupancy snapshot
    const occupancy = await buildOccupancy(filtered);

    // Step 5: visited-today counts aligned to atDt
    // const visitedStats = buildVisitedToday(filtered);
    
    const visitedStats = buildVisitedToday(filtered, atDt);  // this add new code as per function buildVisitedToday change 📝 📝

    // ---- Output timestamps ----
    occupancy.asOfLocal = atDt.toISO(); // Pune-local with offset
    occupancy.asOfUTC   = `${date}T${String(hour).padStart(2,'0')}:${String(minute).padStart(2,'0')}:${String(second).padStart(2,'0')}Z`;

    occupancy.totalVisitedToday = visitedStats.total;
    occupancy.visitedToday = visitedStats;

    return res.json(occupancy);
  } catch (err) {
    console.error('getPuneSnapshotAtDateTime error:', err);
    return res.status(500).json({ error: 'Internal Server Error' });
  }
};

// //////////////////////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////////////////////\


// GET /api/monthly-summary?month=YYYY-MM
exports.getMonthlySummary = async (req, res) => {
  try {
    const { month } = req.query;
    if (!month || !/^\d{4}-\d{2}$/.test(month)) {
      return res.status(400).json({ error: 'invalid "month" format; expected YYYY-MM' });
    }

    const [year, monthNum] = month.split('-').map(Number);

    const start = DateTime.fromObject({ year, month: monthNum, day: 1 }, { zone: 'Asia/Kolkata' });
    const end = start.endOf('month');

    const startUtc = start.setZone('utc').toJSDate();
    const endUtc   = end.setZone('utc').toJSDate();

    const pool = await getPool();
    const reqDb = pool.request();
    reqDb.input('start', sql.DateTime2, startUtc);
    reqDb.input('end', sql.DateTime2, endUtc);

    const { recordset } = await reqDb.query(`
      SELECT
        t1.MessageUTC,
        t1.ObjectName1,  -- Person name
        CASE
          WHEN t3.Name IN ('Contractor','Terminated Contractor') THEN t2.Text12
          ELSE CAST(t2.Int1 AS NVARCHAR)
        END AS EmployeeID,
        t1.ObjectIdentity1 AS PersonGUID,
        t3.Name AS PersonnelType,
        t5d.value AS Direction,
        t1.ObjectName2 AS Door
      FROM [ACVSUJournal_00010029].[dbo].[ACVSUJournalLog] t1
      LEFT JOIN [ACVSCore].[Access].[Personnel]     t2 ON t1.ObjectIdentity1 = t2.GUID
      LEFT JOIN [ACVSCore].[Access].[PersonnelType] t3 ON t2.PersonnelTypeId = t3.ObjectID
      LEFT JOIN [ACVSUJournal_00010029].[dbo].[ACVSUJournalLogxmlShred] t5d
        ON t1.XmlGUID = t5d.GUID AND t5d.Value IN ('InDirection','OutDirection')
      WHERE
        t1.MessageType = 'CardAdmitted'
        AND t1.PartitionName2 = 'APAC.Default'
        AND t1.MessageUTC BETWEEN @start AND @end
      ORDER BY t1.MessageUTC ASC;
    `);

    // Convert to Pune local time
    const events = recordset.map(e => {
      const local = DateTime.fromJSDate(e.MessageUTC, { zone: 'utc' }).setZone('Asia/Kolkata');
      return {
        ...e,
        LocaleMessageTime: local.toJSDate(),
        Dateonly: local.toFormat('yyyy-LL-dd'),
        Swipe_Time: local.toFormat('HH:mm:ss'),
      };
    });

    // Get all dates in the month
    const allDates = [];
    let cursor = start;
    while (cursor <= end) {
      allDates.push(cursor.toFormat('yyyy-LL-dd'));
      cursor = cursor.plus({ days: 1 });
    }

    // Group by day
    const byDay = new Map();
    for (const evt of events) {
      if (!byDay.has(evt.Dateonly)) byDay.set(evt.Dateonly, []);
      byDay.get(evt.Dateonly).push(evt);
    }

    const dailySummaries = [];
    const peakOccupancy = [];
    const visitCounter = new Map();       // track total visits
    const presenceByPerson = new Map();   // track which days each person was present

    // Process each day
    for (const [date, dayEvents] of byDay.entries()) {
      // --- Unique daily headcount ---
      const uniquePeople = new Set(dayEvents.map(e => e.PersonGUID));
      dailySummaries.push({ date, total: uniquePeople.size });

      // --- Peak occupancy counter ---
      let currentCount = 0;
      let maxCount = 0;
      for (const e of dayEvents) {
        if (e.Direction === 'InDirection') {
          currentCount++;
        } else if (e.Direction === 'OutDirection') {
          currentCount = Math.max(0, currentCount - 1);
        }
        if (currentCount > maxCount) maxCount = currentCount;
      }
      peakOccupancy.push({ date, peak: maxCount });

      // --- Track visits & attendance ---
      for (const e of dayEvents) {
        if (e.Direction === 'InDirection') {
          const key = e.PersonGUID || e.EmployeeID || e.ObjectName1;

          // Track visits
          if (!visitCounter.has(key)) {
            visitCounter.set(key, {
              count: 0,
              employeeId: e.EmployeeID,
              name: e.ObjectName1,
              personnelType: e.PersonnelType
            });
          }
          visitCounter.get(key).count++;

          // Track attendance
          if (!presenceByPerson.has(key)) {
            presenceByPerson.set(key, {
              employeeId: e.EmployeeID,
              name: e.ObjectName1,
              personnelType: e.PersonnelType,
              days: new Set()
            });
          }
          presenceByPerson.get(key).days.add(date);
        }
      }
    }

    // --- Final aggregates ---
    const avgDailyHeadcount =
      dailySummaries.reduce((sum, d) => sum + d.total, 0) / dailySummaries.length || 0;

    const top10 = Array.from(visitCounter.values())
      .sort((a, b) => b.count - a.count)
      .slice(0, 10)
      .map(v => ({
        employeeId: v.employeeId,
        name: v.name,
        personnelType: v.personnelType,
        visits: v.count
      }));

    // --- Attendance sheet ---
    const attendanceSheet = Array.from(presenceByPerson.values()).map(p => {
      const daily = {};
      let presentCount = 0;

      for (const d of allDates) {
        if (p.days.has(d)) {
          daily[d] = "P"; // Present
          presentCount++;
        } else {
          daily[d] = "A"; // Absent
        }
      }

      return {
        employeeId: p.employeeId,
        name: p.name,
        personnelType: p.personnelType,
        ...daily,
        daysPresent: presentCount,
        daysAbsent: allDates.length - presentCount,
        attendancePercent: ((presentCount / allDates.length) * 100).toFixed(1) + "%"
      };
    });

    return res.json({
      month,
      avgDailyHeadcount: Math.round(avgDailyHeadcount),
      peakOccupancy,
      top10Visitors: top10,
      attendanceSheet
    });
  } catch (err) {
    console.error('getMonthlySummary error:', err);
    return res.status(500).json({ error: 'Internal Server Error' });
  }
};











// C:\Users\W0024618\Desktop\swipeData\employee-ai-insights\routes\liveOccupancyRoutes.js
const express = require('express');
const router  = express.Router();
const {
  getLiveOccupancy,
  
  getMonthlySummary,
 getPuneSnapshotAtDateTime
} = require('../controllers/liveOccupancyController');

router.get('/live-occupancy', getLiveOccupancy);
// router.get('/occupancy-at', getSnapshotAt);  // GET /api/occupancy-at?at=...

// New snapshot endpoint
router.get('/occupancy-at-time-pune', getPuneSnapshotAtDateTime);

router.get('/monthly-summary', getMonthlySummary);
module.exports = router;




// server.js
require('dotenv').config();
console.log('▶︎ Loading:', __filename);
console.log('▶︎ CWD:', process.cwd());

const express = require('express');
const cors    = require('cors');
const path    = require('path');

// --- Guarded controller imports ---
// Pune (core) controller
let liveCtrl = null;
try {
  liveCtrl = require('./controllers/liveOccupancyController');
} catch (e) {
  console.error('Failed to load liveOccupancyController:', e && e.stack ? e.stack : e);
  liveCtrl = null;
}

// Optional Denver controllers — load them safely (server still starts if they fail)
let denverLiveCtrl = null;
try { denverLiveCtrl = require('./controllers/denverLiveOccupancyController'); } catch (e) {
  console.warn('denverLiveOccupancyController not loaded:', e && e.message ? e.message : e);
}
let denverInOutCtrl = null;
try { denverInOutCtrl = require('./controllers/denverInOutInconsistencyController'); } catch (e) {
  console.warn('denverInOutInconsistencyController not loaded:', e && e.message ? e.message : e);
}
let denverRejectionsCtrl = null;
try { denverRejectionsCtrl = require('./controllers/denverRejection'); } catch (e) {
  console.warn('denverRejection controller not loaded:', e && e.message ? e.message : e);
}

// --- Global process handlers (already good to have) ---
process.on('unhandledRejection', (reason, p) => {
  console.error('❌ Unhandled Rejection at:', p, 'reason:', reason && reason.stack ? reason.stack : reason);
});
process.on('uncaughtException', (err) => {
  console.error('❌ Uncaught exception:', err && err.stack ? err.stack : err);
});

// --- Routes that always exist (employeeRoutes may be optional in your project) ---
let employeeRoutes = null;
try {
  employeeRoutes = require('./routes/employeeRoutes');
} catch (e) {
  console.warn('employeeRoutes not loaded:', e && e.message ? e.message : e);
  employeeRoutes = null;
}

// --- Create app (must come before route registrations) ---
const app = express();
app.use(cors());
app.use(express.json());

// Log every incoming request
app.use((req, res, next) => {
  console.log(`➡︎ ${req.method} ${req.url}`);
  next();
});

// Sanity‐check
app.get('/ping', (req, res) => res.send('pong'));

// SSE no‐buffering helper
const noBuffering = (req, res, next) => {
  res.set('X-Accel-Buffering', 'no');
  next();
};

// 1) Employee API (if available)
if (employeeRoutes) {
  app.use('/api/employees', employeeRoutes);
} else {
  // optional: return 501 for employees route if someone calls it
  app.use('/api/employees', (req, res) => res.status(501).json({ error: 'Employees routes not available' }));
}

// 2) Pune live‐occupancy SSE (guarded)
if (liveCtrl && typeof liveCtrl.getLiveOccupancy === 'function') {
  app.get('/api/live-occupancy', noBuffering, liveCtrl.getLiveOccupancy);
} else {
  app.get('/api/live-occupancy', noBuffering, (req, res) => {
    return res.status(500).json({ error: 'Pune live controller not available' });
  });
}

// Pune snapshot endpoint
if (liveCtrl && typeof liveCtrl.getPuneSnapshotAtDateTime === 'function') {
  app.get('/api/occupancy-at-time-pune', noBuffering, liveCtrl.getPuneSnapshotAtDateTime);
} else {
  app.get('/api/occupancy-at-time-pune', noBuffering, (req, res) => {
    return res.status(500).json({ error: 'Pune snapshot controller not available' });
  });
}

// 3) Denver live‐occupancy SSE (guarded)
app.get('/api/live-occupancy-denver', noBuffering, (req, res, next) => {
  if (denverLiveCtrl && typeof denverLiveCtrl.getDenverLiveOccupancy === 'function') {
    return denverLiveCtrl.getDenverLiveOccupancy(req, res, next);
  }
  return res.status(501).json({ error: 'Denver live occupancy controller not available' });
});

// Denver snapshot
app.get('/api/occupancy-at-time-denver', noBuffering, (req, res, next) => {
  if (denverLiveCtrl && typeof denverLiveCtrl.getDenverSnapshotAtDateTime === 'function') {
    return denverLiveCtrl.getDenverSnapshotAtDateTime(req, res, next);
  }
  return res.status(501).json({ error: 'Denver snapshot controller not available' });
});

// Denver in/out
app.get('/api/inout-inconsistency-denver', noBuffering, (req, res, next) => {
  if (denverInOutCtrl && typeof denverInOutCtrl.getDenverInOutInconsistency === 'function') {
    return denverInOutCtrl.getDenverInOutInconsistency(req, res, next);
  }
  return res.status(501).json({ error: 'Denver in/out controller not available' });
});

// Rejections
app.get('/api/rejections', noBuffering, (req, res, next) => {
  if (denverRejectionsCtrl && typeof denverRejectionsCtrl.getRejections === 'function') {
    return denverRejectionsCtrl.getRejections(req, res, next);
  }
  return res.status(501).json({ error: 'Denver rejections controller not available' });
});

// Serve React build & health
const buildPath = path.join(__dirname, '..', 'client', 'build');
app.use(express.static(buildPath));
app.get('/health', (req, res) => res.send('OK'));

// 404 catcher
app.use((req, res) => {
  console.log(`⚠️  No route for ${req.method} ${req.url}`);
  res.status(404).send(`Cannot ${req.method} ${req.url}`);
});

const PORT = process.env.PORT || 3010;
app.listen(PORT, '0.0.0.0', () =>
  console.log(`✔️  Server listening on http://0.0.0.0:${PORT}`)
);






// src/api.js
import axios from 'axios';

const API_BASE = (process.env.REACT_APP_API_BASE_URL)
  || (process.env.NODE_ENV === 'development' ? 'http://10.199.22.57:3010' : window.location.origin);

const api = axios.create({
  baseURL: `${API_BASE.replace(/\/$/, '')}/api`
});

export default api;










// src/App.js
import React, {
  useEffect,
  useState,
  useRef,
  useCallback,
  lazy,
  Suspense
} from 'react';
import {
  Container,
  Navbar,
  Nav,
  Button,
  InputGroup,
  FormControl,
  Spinner
} from 'react-bootstrap';
import { BrowserRouter, Routes, Route, Link, useLocation } from 'react-router-dom';
import { FaSun } from 'react-icons/fa';

import './App.css';
import './api.js';

// ✅ Lazy load pages (faster initial load)
const DashboardHome = lazy(() => import('./pages/DashboardHome'));
const ErtPage = lazy(() => import('./pages/ErtPage'));
const ZoneDetailsTable = lazy(() => import('./components/ZoneDetailsTable'));

// -----------------------------
// TimeTravelControl
// -----------------------------
function TimeTravelControl({ currentTimestamp, onApply, onLive, loading }) {
  const [local, setLocal] = useState(currentTimestamp ? isoToInput(currentTimestamp) : '');

  useEffect(() => {
    if (currentTimestamp) setLocal(isoToInput(currentTimestamp));
    else setLocal('');
  }, [currentTimestamp]);

  const handleApply = useCallback(() => {
    if (!local) return;
    const selected = new Date(local);
    const now = new Date();
    if (selected > now) {
      window.alert("Please select a relevant time — snapshot cannot be in the future");
      return;
    }
    const [datePart, timePart] = local.split('T');
    onApply(datePart, timePart);
  }, [local, onApply]);

  const handleLive = useCallback(() => {
    setLocal('');
    onLive();
  }, [onLive]);

  return (
    <div style={{ display: 'flex', gap: 8, alignItems: 'center', minWidth: 340 }}>
      <InputGroup>
        <FormControl
          type="datetime-local"
          value={local}
          onChange={(e) => setLocal(e.target.value)}
          placeholder="Select date & time"
        />
      </InputGroup>

      <div style={{ display: 'flex', gap: 6 }}>
        <Button variant="outline-warning" onClick={handleApply} disabled={loading || !local}>
          {loading ? <><Spinner animation="border" size="sm" />&nbsp;Applying</> : 'Apply'}
        </Button>
        <Button variant="warning" onClick={handleLive} disabled={loading}>
          Live
        </Button>
      </div>
    </div>
  );
}

function pad(n) { return String(n).padStart(2, '0'); }
function isoToInput(iso) {
  if (!iso) return '';
  const d = new Date(iso);
  return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}`;
}

// -----------------------------
// ZoneDetailsPage (memoized)
// -----------------------------
const ZoneDetailsPage = React.memo(function ZoneDetailsPage({ detailsData }) {
  const [searchTerm, setSearchTerm] = useState('');

  return (
    <>
      <div
        className="d-flex justify-content-between align-items-center mb-2"
        style={{ flexWrap: 'wrap', gap: '0.5rem' }}
      >
        <Link to="/" className="btn btn-secondary">← Back to Dashboard</Link>
        <input
          type="text"
          placeholder="Search employee..."
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          style={{
            flexGrow: 1,
            maxWidth: 300,
            padding: '0.4rem 0.8rem',
            fontSize: '1rem',
            borderRadius: 4,
            border: '1px solid #ccc'
          }}
        />
      </div>
      <Suspense fallback={<div>Loading details…</div>}>
        <ZoneDetailsTable data={detailsData} searchTerm={searchTerm} />
      </Suspense>
    </>
  );
});

// -----------------------------
// Main App
// -----------------------------
function App() {
  const esRef = useRef(null);
  const sseBufferRef = useRef(null);
  const sseFlushScheduledRef = useRef(false);

  const location = useLocation();
  const headerText = location.pathname === '/ert'
    ? 'Emergency Response Team — Western Union Pune'
    : 'Live Occupancy — Western Union Pune';

  // ---------- CONFIG: API base URL ----------
  // NOTE: development default set to your backend server IP:port
  const API_BASE = (process.env.REACT_APP_API_BASE_URL)
    || (process.env.NODE_ENV === 'development' ? 'http://10.199.22.57:3010' : window.location.origin);
  const API_ORIGIN = API_BASE.replace(/\/$/, '');
  // ------------------------------------------

  const [liveData, setLiveData] = useState({
    summary: [],
    details: {},
    floorBreakdown: [],
    zoneBreakdown: [],
    personnelBreakdown: [],
    totalVisitedToday: 0,
    personnelSummary: { employees: 0, contractors: 0 },
    visitedToday: { employees: 0, contractors: 0, total: 0 },
    ertStatus: {}
  });

  const [timeTravelMode, setTimeTravelMode] = useState(false);
  const [timeTravelTimestamp, setTimeTravelTimestamp] = useState(null);
  const [timeTravelLoading, setTimeTravelLoading] = useState(false);

  // SSE with throttling
  useEffect(() => {
    if (timeTravelMode) {
      if (esRef.current) esRef.current.close();
      esRef.current = null;
      return;
    }

    const esUrl = `${API_ORIGIN}/api/live-occupancy`;
    console.info('[SSE] connecting to', esUrl);
    const es = new EventSource(esUrl);
    esRef.current = es;

    es.onopen = () => {
      console.info('[SSE] connection opened');
    };

    es.onmessage = (e) => {
      try {
        const p = JSON.parse(e.data);
        sseBufferRef.current = p;

        if (!sseFlushScheduledRef.current) {
          sseFlushScheduledRef.current = true;
          setTimeout(() => {
            setLiveData(sseBufferRef.current);
            sseFlushScheduledRef.current = false;
          }, 500); // throttle updates to every 0.5s
        }
      } catch (err) {
        console.error('[SSE] parse error', err);
      }
    };

    es.onerror = (errEvent) => {
      // errEvent is a browser Event — log a compact message and leave EventSource to auto-retry
      console.error('[SSE] error connecting to', esUrl, errEvent);
      try { es.close(); } catch (e) {}
      esRef.current = null;
    };

    return () => {
      try { es.close(); } catch (e) {}
      esRef.current = null;
    };
  }, [timeTravelMode, API_ORIGIN]);

  // Unified payload setter
  const setPayload = useCallback((p) => {
    setLiveData({
      summary: Array.isArray(p.summary) ? p.summary : [],
      details: p.details || {},
      floorBreakdown: Array.isArray(p.floorBreakdown) ? p.floorBreakdown : [],
      zoneBreakdown: Array.isArray(p.zoneBreakdown) ? p.zoneBreakdown : [],
      personnelBreakdown: Array.isArray(p.personnelBreakdown) ? p.personnelBreakdown : [],
      totalVisitedToday: typeof p.totalVisitedToday === 'number' ? p.totalVisitedToday : 0,
      personnelSummary: p.personnelSummary || { employees: 0, contractors: 0 },
      visitedToday: p.visitedToday || { employees: 0, contractors: 0, total: 0 },
      ertStatus: p.ertStatus || {}
    });
  }, []);

  // Fetch a historical snapshot
  const fetchSnapshot = useCallback(async (dateStr, timeStr) => {
    setTimeTravelLoading(true);
    const safeTime = timeStr.length === 5 ? `${timeStr}:00` : timeStr;
    const url = `${API_ORIGIN}/api/occupancy-at-time-pune?date=${encodeURIComponent(dateStr)}&time=${encodeURIComponent(safeTime)}`;

    try {
      const resp = await fetch(url, { method: 'GET', headers: { 'Accept': 'application/json' } });
      if (!resp.ok) {
        const body = await resp.text().catch(() => '');
        console.error(`[TimeTravel] error ${resp.status} from ${url}`, body);
        window.alert(`Failed to load snapshot (${resp.status}). See console for details.`);
        throw new Error(`Server returned ${resp.status}`);
      }

      const p = await resp.json();
      setPayload(p);
      setTimeTravelMode(true);
      setTimeTravelTimestamp(p?.asOfLocal || `${dateStr} ${safeTime}`);
    } catch (err) {
      console.error('Failed to fetch snapshot', err);
      if (!err.message.includes('Server returned')) {
        window.alert('Failed to load snapshot. See console for details.');
      }
    } finally {
      setTimeTravelLoading(false);
    }
  }, [API_ORIGIN, setPayload]);

  // Return to live mode — do NOT fetch the SSE stream with fetch()
  const clearTimeTravel = useCallback(async () => {
    setTimeTravelLoading(true);
    try {
      setTimeTravelMode(false);
      setTimeTravelTimestamp(null);
      // allow SSE effect to reconnect and deliver fresh payload
      sseBufferRef.current = null;
    } finally {
      setTimeTravelLoading(false);
    }
  }, []);

  return (
    <>
      <Navbar bg="dark" variant="dark" expand="lg" className="px-3">
        <Navbar.Brand as={Link} to="/" className="wu-brand">
          {headerText}
        </Navbar.Brand>

        <Navbar.Toggle aria-controls="main-navbar" />
        <Navbar.Collapse id="main-navbar">
          <Nav className="ms-auto align-items-center gap-2">
            <div className="time-travel-wrapper me-2">
              <TimeTravelControl
                currentTimestamp={timeTravelTimestamp}
                onApply={fetchSnapshot}
                onLive={clearTimeTravel}
                loading={timeTravelLoading}
              />
            </div>

            <Nav.Link as={Link} to="/" className="nav-item-infographic">
              <i className="bi bi-house"></i>
            </Nav.Link>
            <Nav.Link href={`http://10.199.22.57:3000/partition/Pune/history`} className="nav-item-infographic">
              <i className="bi bi-clock-history"></i>
            </Nav.Link>
            <Nav.Link as={Link} to="/details" className="nav-item-infographic">
              <i className="fa-solid fa-calendar-day"></i>
            </Nav.Link>
            <Nav.Link as={Link} to="/ert" className="nav-item-infographic">
              ERT Overview
            </Nav.Link>
            <Nav.Link className="theme-toggle-icon" title="Dark mode only">
              <FaSun />
            </Nav.Link>
          </Nav>
        </Navbar.Collapse>
      </Navbar>

      <Container fluid className="mt-2">
        {timeTravelMode && (
          <div style={{
            background: '#434d44',
            color: '#FFF',
            padding: '8px 16px',
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            borderLeft: '4px solid rgb(0, 255, 21)',
            marginBottom: 8
          }}>
            <div>
              Viewing historical snapshot for:&nbsp;
              <strong>{new Date(timeTravelTimestamp).toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' })}</strong>
            </div>
            <div>
              <button
                className="btn btn-sm btn-outline-warning"
                onClick={clearTimeTravel}
                disabled={timeTravelLoading}
              >
                Return to Live
              </button>
            </div>
          </div>
        )}

        <Suspense fallback={<div style={{ color: '#FFC72C' }}>Loading page…</div>}>
          <Routes>
            <Route
              path="/"
              element={
                <DashboardHome
                  summaryData={liveData.summary}
                  detailsData={liveData.details}
                  floorData={liveData.floorBreakdown}
                  zoneBreakdown={liveData.zoneBreakdown}
                  personnelBreakdown={liveData.personnelBreakdown}
                  totalVisitedToday={liveData.totalVisitedToday}
                  personnelSummary={liveData.personnelSummary}
                  visitedToday={liveData.visitedToday}
                  ertStatus={liveData.ertStatus}
                />
              }
            />
            <Route path="/details" element={<ZoneDetailsPage detailsData={liveData.details} />} />
            <Route path="/ert" element={<ErtPage ertStatus={liveData.ertStatus} />} />
          </Routes>
        </Suspense>
      </Container>

      <style>{`
/* Brand text scales */
.wu-brand {
  font-size: clamp(1rem, 1.5vw, 1.4rem);
  white-space: normal;
}

/* Navbar link icons spacing */
.nav-item-infographic {
  font-size: 1.1rem;
  padding: 0.4rem;
}

.theme-toggle-icon {
  font-size: 1.25rem;
}

/* --- Breakpoints --- */

/* Mobile (<576px) */
@media (max-width: 575.98px) {
  .time-travel-wrapper {
    width: 100%;
    margin-bottom: 0.75rem;
  }
}

/* Tablet (≥576px and <992px) */
@media (min-width: 576px) and (max-width: 991.98px) {
  .time-travel-wrapper {
    flex: 1;
    min-width: 280px;
  }
}

/* Laptop & Desktop (≥992px) */
@media (min-width: 992px) {
  .time-travel-wrapper {
    min-width: 340px;
    margin-bottom: 0;
  }
}
      `}</style>
    </>
  );
}

export default function WrappedApp() {
  return (
    <BrowserRouter>
      <div className="dark-theme">
        <App />
      </div>
    </BrowserRouter>
  );
}







D:\DASHBOARD\swipeData\client\src\index.js


import React from 'react';
import 'bootstrap/dist/css/bootstrap.min.css';
import ReactDOM from 'react-dom/client'; // correct import for React 18+
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// Optional: log performance metrics
reportWebVitals();








// src/pages/DashboardHome.jsx
import React, { useMemo, lazy, Suspense, useDeferredValue } from 'react';
import { Container, Row, Col } from 'react-bootstrap';

import SummaryCards from '../components/SummaryCards';
import LoadingSpinner from '../components/LoadingSpinner';

// lazy-load charts (prefetch so browser can warm the chunk after idle)
const FloorOccupancyChart = lazy(() => import(
  /* webpackChunkName: "floor-chart", webpackPrefetch: true */ '../components/FloorOccupancyChart'
));
const SummaryChart = lazy(() => import(
  /* webpackChunkName: "summary-chart", webpackPrefetch: true */ '../components/SummaryChart'
));
const PersonnelDonutChart = lazy(() => import(
  /* webpackChunkName: "personnel-donut", webpackPrefetch: true */ '../components/PersonnelDonutChart'
));

/**
 * DashboardHome
 * - Always render SummaryCards immediately (fast first meaningful paint)
 * - Defer heavy chart rendering with useDeferredValue + Suspense fallbacks
 * - Memoize chart data so children only get new props when the source changes
 */
function DashboardHome({
  summaryData = [],
  detailsData,
  floorData = [],
  zoneBreakdown,
  personnelBreakdown = [],
  totalVisitedToday = 0,
  personnelSummary = { employees: 0, contractors: 0 },
  visitedToday = {},
  ertStatus
}) {
  // small cheap derived numbers shown in SummaryCards (fast)
  const employees = personnelSummary?.employees ?? 0;
  const contractors = personnelSummary?.contractors ?? 0;
  const totalOccupancy = employees + contractors;

  // memoize chart input transforms (cheap => prevents child re-render unless source changes)
  const chartData = useMemo(() => {
    return (personnelBreakdown || []).map(({ personnelType, count }) => ({ personnelType, count }));
  }, [personnelBreakdown]);

  // useDeferredValue prevents urgent UI (summary cards) from being blocked by chart updates
  const deferredChartData = useDeferredValue(chartData);
  const deferredFloorData = useDeferredValue(floorData || []);
  const deferredSummary = useDeferredValue(summaryData || []);

  // NOTE: Do NOT block entire page on charts. Always show summary cards immediately.
  // Charts will show loading placeholders until their lazy chunks and data are ready.

  return (
    <Container fluid className="py-4">
      {/* Summary: first meaningful paint (always show with minimal compute) */}
      <SummaryCards
        totalOccupancy={totalOccupancy}
        employeeCount={employees}
        contractorCount={contractors}
        totalVisitedToday={totalVisitedToday}
        employeesVisitedToday={visitedToday?.employees ?? 0}
        contractorsVisitedToday={visitedToday?.contractors ?? 0}
      />

      {/* Charts row — lazy rendered with Suspense fallback */}
      <Row className="g-4" style={{ marginTop: 12 }}>
        <Col md={4} style={{ minHeight: 300 }}>
          <Suspense fallback={<div style={{height: '100%', display:'flex', alignItems:'center', justifyContent:'center'}}><LoadingSpinner message="Loading chart…" small /></div>}>
            <FloorOccupancyChart data={deferredFloorData} />
          </Suspense>
        </Col>

        <Col md={4} style={{ minHeight: 300 }}>
          <Suspense fallback={<div style={{height: '100%', display:'flex', alignItems:'center', justifyContent:'center'}}><LoadingSpinner message="Loading chart…" small /></div>}>
            <SummaryChart summary={deferredSummary} />
          </Suspense>
        </Col>

        <Col md={4} style={{ minHeight: 300 }}>
          <Suspense fallback={<div style={{height: '100%', display:'flex', alignItems:'center', justifyContent:'center'}}><LoadingSpinner message="Loading chart…" small /></div>}>
            <PersonnelDonutChart data={deferredChartData} />
          </Suspense>
        </Col>
      </Row>

      {/* Footer — reserved space to reduce layout shift */}
      <footer style={{
        backgroundColor: '#000',
        color: '#FFC72C',
        padding: '1.5rem 0',
        textAlign: 'center',
        marginTop: '0rem',
        borderTop: '2px solid #FFC72C',
        fontSize: '0.95rem',
        lineHeight: '1.6',
        minHeight: 120
      }}>
        <div><strong>Global Security Operations Center</strong><br />
          Live HeadCount against Occupancy dashboard for Western Union Pune — Real-time occupancy, floor activity, and personnel insights.
        </div>
        <div style={{ marginTop: '0.75rem' }}>
          Contact us:&nbsp;
          <a href="mailto:GSOC-GlobalSecurityOperationCenter.SharedMailbox@westernunion.com"
             style={{ color: '#FFC72C', textDecoration: 'underline' }}>
            GSOC Mail
          </a>&nbsp;|&nbsp;
          Landline:&nbsp;<span style={{ color: '#FFC72C' }}>+91-020-67632394</span>
        </div>
      </footer>
    </Container>
  );
}

export default React.memo(DashboardHome);







