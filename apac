



//C:\Users\W0024618\Desktop\apac-occupancy-frontend\src\pages\History.jsx
import React, { useEffect, useState, useMemo,useCallback } from 'react';
import { useParams } from 'react-router-dom';
import {
  Container,
  Box,
  Button,
  Typography,
  Table,
  TableHead,
  TableBody,
  TableRow,
  TableCell,
  Paper,
  TextField,
  TableContainer
} from '@mui/material';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { LocalizationProvider, DatePicker } from '@mui/x-date-pickers';
import { format } from 'date-fns';
import { subDays } from 'date-fns';


import ExcelJS from 'exceljs';
import { saveAs } from 'file-saver';

import Header from '../components/Header';
import Footer from '../components/Footer';
import LoadingSpinner from '../components/LoadingSpinner';
import { fetchHistory } from '../api/occupancy.service';

// APAC display mapping
const apacPartitionDisplay = {
  'IN.Pune': { country: 'India', city: 'Pune' },
  'MY.Kuala Lumpur': { country: 'Malaysia', city: 'Kuala Lumpur' },
  'PH.Quezon': { country: 'Philippines', city: 'Quezon City' },
  'PH.Taguig': { country: 'Philippines', city: 'Taguig' },
  'JP.Tokyo': { country: 'Japan', city: 'Tokyo' },
  'IN.HYD': { country: 'India', city: 'Hyderabad' },

};

// FE ↔ BE keys
const apacForwardKey = {
  'IN.Pune': 'Pune',
  'MY.Kuala Lumpur': 'MY.Kuala Lumpur',
  'PH.Quezon': 'Quezon City',
  'PH.Taguig': 'Taguig City',
  'JP.Tokyo': 'JP.Tokyo',
  'IN.HYD': 'IN.HYD',

};
const apacReverseKey = Object.fromEntries(
  Object.entries(apacForwardKey).map(([fe, be]) => [be, fe])
);

// helper to display “Quezon City” → “Quezon City”
const formatPartition = key => {
  const fe = apacReverseKey[key];
  return fe
    ? apacPartitionDisplay[fe].city
    : key;
};

// helper: unify the key format used by companyRows and detailRows
const makeCompanyKey = (country, city, company) => `${country}||${city}||${company}`;

export default function History() {
  const { partition } = useParams();
  const decodedPartition = partition ? decodeURIComponent(partition) : null;
  const backendFilterKey = decodedPartition
    ? apacForwardKey[decodedPartition] || decodedPartition
    : null;

  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  // const [pickedDate, setPickedDate] = useState(null);
  const [pickedDate, setPickedDate] = useState(() => new Date());
  const [showDetails, setShowDetails] = useState(false);

  // new: company click/filter state
  const [selectedCompany, setSelectedCompany] = useState(null);
  // NEW: personnel header filter state
  const [selectedPersonnel, setSelectedPersonnel] = useState(null); // 'Employee' | 'Contractor' | null
  const [selectedSummaryPartition, setSelectedSummaryPartition] = useState(null);

  // near top of component state
  const [indexByDate, setIndexByDate] = useState({
    detailMap: new Map(),   // date (yyyy-mm-dd) => Array<detailRows>
    summaryMap: new Map()   // date (yyyy-mm-dd) => summaryEntry
  });

  const CACHE_TTL_MS = 24 * 60 * 60 * 1000; // 24 hours fallback TTL

  const cacheKeyFor = (backendKey) => `history_cache_${backendKey || 'all'}`;

  // clear company selection when date changes
  // const saveHistoryCache = (backendKey, json) => {
  //   try {
  //     const version = json?.meta?.version || json?.generated_at || null;
  //     const payload = { fetchedAt: Date.now(), version, json };
  //     localStorage.setItem(cacheKeyFor(backendKey), JSON.stringify(payload));
  //   } catch (err) {
  //     console.warn('saveHistoryCache error', err);
  //   }
  // };

  // const loadHistoryCache = (backendKey) => {
  //   try {
  //     const raw = localStorage.getItem(cacheKeyFor(backendKey));
  //     return raw ? JSON.parse(raw) : null;
  //   } catch (err) {
  //     console.warn('loadHistoryCache error', err);
  //     return null;
  //   }
  // };

  

const saveHistoryCache = useCallback((backendKey, json) => {
  try {
    const version = json?.meta?.version || json?.generated_at || null;
    const payload = { fetchedAt: Date.now(), version, json };
    localStorage.setItem(cacheKeyFor(backendKey), JSON.stringify(payload));
  } catch (err) {
    console.warn('saveHistoryCache error', err);
  }
}, []);

const loadHistoryCache = useCallback((backendKey) => {
  try {
    const raw = localStorage.getItem(cacheKeyFor(backendKey));
    return raw ? JSON.parse(raw) : null;
  } catch (err) {
    console.warn('loadHistoryCache error', err);
    return null;
  }
}, []);



  const clearHistoryCache = (backendKey) => {
    try {
      localStorage.removeItem(cacheKeyFor(backendKey));
    } catch (err) {
      console.warn('clearHistoryCache error', err);
    }
  };

  // --- company name normalizer ---
  // keep it deterministic and conservative (only maps the families you listed)
  const normalizeCompany = (raw) => {
    if (!raw) return 'Unknown';
    // trim and collapse whitespace
    const orig = String(raw).trim();
    const s = orig
      .toLowerCase()
      // remove punctuation commonly causing variants
      // .replace(/[.,()\/\-]/g, ' ')
      .replace(/[.,()/-]/g, ' ')
      .replace(/\s+/g, ' ')
      .trim();

    // Poona / Poona Security family
    if (/\bpoona\b/.test(s) || /\bpoona security\b/.test(s) || /\bpoona security india\b/.test(s)) {
      return 'Poona Security India Pvt Ltd';
    }


    if (
      /\bwestern union\b/.test(s) ||
      /\bwesternunion\b/.test(s) ||
      /\bwu\b/.test(s) ||
      /\bwufs\b/.test(s) ||
      /\bwu technology\b/.test(s) ||
      /\bwu srvcs\b/.test(s) ||
      /\bwestern union svs\b/.test(s) ||
      /\bwestern union processing\b/.test(s) ||
      /\bwestern union japan\b/.test(s) ||
      /\bwestern union, llc\b/.test(s)
    ) {
      return 'Western Union';
    }

    // Vedant family
    if (/\bvedant\b/.test(s)) {
      return 'Vedant Enterprises Pvt. Ltd';
    }

    // Osource family
    if (/\bosource\b/.test(s)) {
      return 'Osource India Pvt Ltd';
    }

    // CBRE family
    if (/\bcbre\b/.test(s)) {
      return 'CBRE';
    }

    // explicit Unknown canonical
    if (s === 'unknown' || s === '') return 'Unknown';

    // otherwise return the original trimmed string (preserve casing)
    return orig;
  };


  // New useEffect that uses cache + one fetch if required
  useEffect(() => {
   let active = true;
  const backendKey = backendFilterKey || 'all';

    const buildIndexAndSet = (json) => {
      const detailMap = new Map();
      (json.details || []).forEach(r => {
        const d = (r.LocaleMessageTime && r.LocaleMessageTime.slice(0, 10))
          || (r.SwipeDate && r.SwipeDate.slice(0, 10))
          || 'unknown';
        if (!detailMap.has(d)) detailMap.set(d, []);
        detailMap.get(d).push(r);
      });

      const summaryMap = new Map();
      (json.summaryByDate || []).forEach(s => {
        const key = (s.date || '').slice(0, 10);
        summaryMap.set(key, s);
      });

      if (!active) return;
      setData(json || { details: [], summaryByDate: [] });
      setIndexByDate({ detailMap, summaryMap });
    };

    (async () => {
      setLoading(true);

      const cached = loadHistoryCache(backendKey);
      const now = Date.now();
      let usedCache = false;

      if (cached && cached.json) {
        const cachedVersion = cached.version || null;
        if (cachedVersion && (now - (cached.fetchedAt || 0)) < CACHE_TTL_MS) {
          buildIndexAndSet(cached.json);
          usedCache = true;
          setLoading(false);
        } else if (!cachedVersion && (now - (cached.fetchedAt || 0)) < CACHE_TTL_MS) {
          buildIndexAndSet(cached.json);
          usedCache = true;
          setLoading(false);
        }
        // We'll still check server in background below (to detect new version)
      }

      // fetch once (either to validate or to populate fresh cache)
      try {
        const json = await fetchHistory(decodedPartition);
        if (!active) return;
        const serverVersion = json?.meta?.version || json?.generated_at || null;

        // if we had cached version and it matches, nothing to do (unless we didn't use cache)
        if (cached && cached.version && cached.version === serverVersion && usedCache) {
          // nothing
        } else {
          saveHistoryCache(backendKey, json);
          buildIndexAndSet(json);
        }
      } catch (err) {
        console.error('fetchHistory error', err);
        // fall back to cached data if fetch failed
        if (cached && cached.json && !usedCache) {
          buildIndexAndSet(cached.json);
        }
      } finally {
        if (active) setLoading(false);
      }
    })();

     return () => { active = false; };
}, [decodedPartition, CACHE_TTL_MS, backendFilterKey, loadHistoryCache, saveHistoryCache]);




  useEffect(() => {
    setSelectedCompany(null);
  }, [pickedDate]);


  // summaryEntry: use indexed map
  const summaryEntry = useMemo(() => {
    if (!indexByDate.summaryMap || !pickedDate) return null;
    const ds = format(pickedDate, 'yyyy-MM-dd');
    // exact lookup — no O(n) find
    return indexByDate.summaryMap.get(ds) || null;
  }, [indexByDate.summaryMap, pickedDate]);

  const partitionRows = useMemo(() => {
    if (!summaryEntry) return [];
    if (backendFilterKey && summaryEntry.region) {
      const fe = Object.keys(apacPartitionDisplay).find(
        code => apacForwardKey[code] === backendFilterKey || code === backendFilterKey
      );
      const disp = fe ? apacPartitionDisplay[fe] : {};
      return [{
        country: disp.country || 'Unknown',
        city: disp.city || backendFilterKey.replace(' City', ''),
        employee: summaryEntry.region.Employee || 0,
        contractor: summaryEntry.region.Contractor || 0,
        total: summaryEntry.region.total || 0
      }];
    }
    return Object.entries(summaryEntry.partitions).map(([key, v]) => {
      const fe = Object.entries(apacForwardKey).find(([, be]) =>
        be === key || `${be} City` === key
      )?.[0];
      const disp = fe
        ? apacPartitionDisplay[fe]
        : Object.values(apacPartitionDisplay)
          .find(d => d.city === key.replace(' City', ''));
      return {
        country: disp?.country || 'Unknown',
        city: disp?.city || key.replace(' City', ''),
        employee: v.Employee || v.EmployeeCount || 0,
        contractor: v.Contractor || v.ContractorCount || 0,
        total: v.total || 0
      };
    });
  }, [summaryEntry, backendFilterKey]);

  const formatApiTime12 = iso => {
    if (!iso) return "";
    // get HH:MM:SS part from ISO like "2025-08-28T10:22:33.000Z"
    const tp = (iso && iso.slice(11, 19)) || "";
    if (!tp) return "";
    const [hStr, mStr, sStr] = tp.split(':');   // ✅ now include seconds
    const hh = parseInt(hStr, 10);
    if (Number.isNaN(hh)) return tp;
    let h12 = hh % 12;
    if (h12 === 0) h12 = 12;
    const ampm = hh >= 12 ? "PM" : "AM";
    return `${String(h12).padStart(2, "0")}:${mStr}:${sStr} ${ampm}`;
  };

  // helper: compute canonical company for a single detail row (same logic used by companyRows)
  const getCanonicalCompany = (r) => {
    const rawCompany = (r.CompanyName || '').toString().trim();
    const pt = (r.PersonnelType || '').toString().trim().toLowerCase();
    const s = rawCompany.toLowerCase();

    if (s && /\bcbre\b/.test(s) && (/\bclr\b/.test(s) || /\bfacilit/i.test(s))) {
      return 'CLR Facility Services Pvt.Ltd.';
    }

    if (s && (s === 'cbre' || normalizeCompany(rawCompany) === 'CBRE')) {
      if (pt.includes('property') || pt.includes('management') || pt === 'property management') {
        return 'CLR Facility Services Pvt.Ltd.';
      }
      return 'CBRE';
    }

    if (!rawCompany) {
      if (pt.includes('contractor')) return 'CBRE';
      if (pt.includes('property') || pt.includes('management') || pt === 'property management') {
        return 'CLR Facility Services Pvt.Ltd.';
      }
      if (pt === 'employee') return 'Western Union';
      if (pt.includes('visitor')) return 'Visitor';
      if (pt.includes('temp')) return 'Temp Badge';
      return 'Unknown';
    }
    return normalizeCompany(rawCompany);
  };



  // companyRows
  const detailRows = useMemo(() => {
    if (!indexByDate.detailMap || !pickedDate || !showDetails) return [];
    const ds = format(pickedDate, 'yyyy-MM-dd');
    const rows = indexByDate.detailMap.get(ds) || [];

    return rows
      .filter(r => {
        if (backendFilterKey) {
          const ok = r.PartitionNameFriendly === backendFilterKey ||
            apacForwardKey[r.PartitionNameFriendly] === backendFilterKey;
          if (!ok) return false;
        }
        if (selectedPersonnel) {
          const pt = String(r.PersonnelType || '').toLowerCase();
          if (selectedPersonnel === 'Employee') {
            if (!(pt.includes('employee') || pt.includes('staff') || pt === 'employee')) return false;
          } else {
            if (!(pt.includes('contractor') || pt.includes('vendor') || pt.includes('subcontract') || pt.includes('cont'))) return false;
          }
        }
        if (selectedSummaryPartition) {
          const [selCountry, selCity] = (selectedSummaryPartition || '').split('||');
          const city = formatPartition(r.PartitionNameFriendly || '');
          const disp = Object.values(apacPartitionDisplay).find(d => d.city === city);
          const country = disp?.country || 'Unknown';
          if (country !== selCountry || city !== selCity) return false;
        }
        if (!selectedCompany) return true;
        const city = formatPartition(r.PartitionNameFriendly || '');
        const disp = Object.values(apacPartitionDisplay).find(d => d.city === city);
        const country = disp?.country || 'Unknown';
        const canonical = getCanonicalCompany(r);
        const rowKey = makeCompanyKey(country, city, canonical);
        return rowKey === selectedCompany;
      })
      .sort((a, b) => (a.LocaleMessageTime || '').localeCompare(b.LocaleMessageTime || ''));
  }, [indexByDate.detailMap, pickedDate, showDetails, backendFilterKey, selectedCompany, selectedPersonnel, selectedSummaryPartition]);

  const companyRows = useMemo(() => {
    if (!indexByDate.detailMap || !pickedDate) return [];
    const ds = format(pickedDate, 'yyyy-MM-dd');
    const rows = indexByDate.detailMap.get(ds) || []; // only this date's rows

    // apply partition and personnel filters on this smaller array
    const filtered = rows.filter(r => {
      if (backendFilterKey) {
        const ok = r.PartitionNameFriendly === backendFilterKey ||
          apacForwardKey[r.PartitionNameFriendly] === backendFilterKey;
        if (!ok) return false;
      }
      if (selectedPersonnel) {
        const pt = String(r.PersonnelType || '').toLowerCase();
        if (selectedPersonnel === 'Employee') {
          if (!(pt.includes('employee') || pt.includes('staff') || pt === 'employee')) return false;
        } else {
          if (!(pt.includes('contractor') || pt.includes('vendor') || pt.includes('subcontract') || pt.includes('cont'))) return false;
        }
      }
      return true;
    });

    // aggregate
    const map = new Map();
    filtered.forEach(r => {
      const city = formatPartition(r.PartitionNameFriendly || '');
      const disp = Object.values(apacPartitionDisplay).find(d => d.city === city);
      const country = disp?.country || 'Unknown';
      if (selectedSummaryPartition) {
        const [selCountry, selCity] = selectedSummaryPartition.split('||');
        if (country !== selCountry || city !== selCity) return;
      }
      const company = getCanonicalCompany(r);
      const key = `${country}||${city}||${company}`;
      const existing = map.get(key);
      if (existing) existing.total += 1;
      else map.set(key, { country, city, company, total: 1 });
    });

    return Array.from(map.values()).sort((a, b) => {
      if (a.country !== b.country) return a.country.localeCompare(b.country);
      if (a.city !== b.city) return a.city.localeCompare(b.city);
      return a.company.localeCompare(b.company);
    });
  // }, [indexByDate.detailMap, pickedDate, backendFilterKey, selectedPersonnel, selectedSummaryPartition,getCanonicalCompany]); // trimmed deps
  }, [indexByDate.detailMap, pickedDate, backendFilterKey, selectedPersonnel, selectedSummaryPartition, getCanonicalCompany]);

  // helper: convert 1-based column number to Excel letter (works for up to Z)
  const colLetter = (n) => String.fromCharCode(64 + n);
  /* ------------------ handleExport (Details) ------------------ */
  const handleExport = async () => {
    if (!pickedDate) return;

    try {
      const excelModule = await import('exceljs');
      const Excel = excelModule.default || excelModule;
      let wb;

      if (Excel && Excel.Workbook) wb = new Excel.Workbook();
      else if (typeof Excel === 'function') wb = new Excel();
      else throw new Error('ExcelJS Workbook constructor not found');

      const wsDetails = wb.addWorksheet('WU Employee');

      // layout offsets: skip one row and one column before/after data
      const offsetRow = 2; // leave row 1 blank, put title in row 2
      const offsetCol = 2; // leave column A blank, start data at column B

      // Headers
      const detailsHeaders = [
        'Sr.No', 'Date', 'Time',
        'Employee Name', 'Employee ID', 'Personal Type',
        'Door Name', 'Location'
      ];
      const firstCol = offsetCol;
      const lastCol = offsetCol + detailsHeaders.length - 1;

      // Title row (at offsetRow)
      const titleStart = colLetter(firstCol) + offsetRow;
      const titleEnd = colLetter(lastCol) + offsetRow;
      wsDetails.mergeCells(`${titleStart}:${titleEnd}`);
      const detailsTitle = wsDetails.getCell(offsetRow, firstCol);
      detailsTitle.value = `${format(pickedDate, 'EEEE, d MMMM, yyyy')}`;
      // Colour & font for title (black bg, yellow text)
      detailsTitle.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF000000' } };
      detailsTitle.font = { name: 'Calibri', size: 12, bold: true, color: { argb: 'FFFFC107' } };
      detailsTitle.alignment = { horizontal: 'center', vertical: 'middle' };

      // Make title row height tighter (will be overridden to 22 below globally)
      wsDetails.getRow(offsetRow).height = 22;

      // Also apply same fill & border to each cell in merged range for consistent appearance
      for (let c = firstCol; c <= lastCol; c++) {
        const cell = wsDetails.getCell(offsetRow, c);
        cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF000000' } };
        cell.font = { name: 'Calibri', size: 12, bold: true, color: { argb: 'FFFFC107' } };
        // thick outside border for top header (we'll set medium around the title row cells)
        cell.border = {
          top: { style: 'medium' },
          bottom: { style: 'medium' },
          left: { style: 'medium' },
          right: { style: 'medium' }
        };
      }

      // Header row index
      const headerRowIndex = offsetRow + 1; // e.g., 3
      const headerRow = wsDetails.getRow(headerRowIndex);
      headerRow.height = 22;

      // Insert header values at correct columns
      detailsHeaders.forEach((h, idx) => {
        const colIndex = firstCol + idx;
        const cell = wsDetails.getCell(headerRowIndex, colIndex);
        cell.value = h;
        // header style: yellow fill, bold, centered (except Door column data alignment)
        cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFC107' } };
        cell.font = { name: 'Calibri', size: 11, bold: true, color: { argb: 'FF000000' } };
        // medium border for header (thick)
        cell.border = {
          top: { style: 'medium' }, left: { style: 'medium' }, bottom: { style: 'medium' }, right: { style: 'medium' }
        };
        // default header alignment center
        cell.alignment = { horizontal: 'center', vertical: 'middle' };
      });

      // Data rows start at headerRowIndex + 1
      const dataStartRow = headerRowIndex + 1;
      (detailRows || []).forEach((r, i) => {
        const rowIndex = dataStartRow + i;
        const row = wsDetails.getRow(rowIndex);
        // set data row height to 22
        row.height = 22;

        const dateVal = (r.LocaleMessageTime?.slice(0, 10)) || (r.SwipeDate?.slice(0, 10)) || '';
        const timeVal = formatApiTime12(r.LocaleMessageTime) || '';
        const name = r.ObjectName1 || '';
        const empId = r.EmployeeID || '';
        const ptype = r.PersonnelType || '';
        const door = r.Door || r.ObjectName2 || '';
        const location = r.PartitionNameFriendly || '';

        const values = [i + 1, dateVal, timeVal, name, empId, ptype, door, location];

        values.forEach((val, idx) => {
          const colIndex = firstCol + idx;
          const cell = wsDetails.getCell(rowIndex, colIndex);
          cell.value = val;
          // default inner cell border thin
          cell.border = {
            top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' }
          };
          // font + vertical center
          cell.font = { name: 'Calibri', size: 10, color: { argb: 'FF000000' } };
          // Door Name column (7th header) -> index 6 (0-based), column number = firstCol + 6
          const doorColIndex = firstCol + 6;
          if (colIndex === doorColIndex) {
            cell.alignment = { horizontal: 'left', vertical: 'middle' };
          } else {
            cell.alignment = { horizontal: 'center', vertical: 'middle' };
          }
        });

        // optional alternating fill for readability (keeps gridlines hidden but visual rows)
        if (i % 2 === 1) {
          values.forEach((_, idx) => {
            const colIndex = firstCol + idx;
            const cell = wsDetails.getCell(rowIndex, colIndex);
            cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFF7F7F7' } };
          });
        }
      });

      // After data: add one empty row (skip one row after)
      const lastDataRow = (detailRows?.length ? dataStartRow + detailRows.length - 1 : headerRowIndex);
      const blankRow = wsDetails.addRow([]); // blank row after data
      blankRow.height = 22;

      // Hide gridlines and freeze panes so header stays visible
      wsDetails.views = [{ state: 'frozen', ySplit: headerRowIndex, showGridLines: false }];

      // Autosize columns for the used area (firstCol..lastCol)
      for (let c = firstCol; c <= lastCol; c++) {
        let maxLen = 0;
        for (let r = offsetRow; r <= lastDataRow; r++) {
          const cell = wsDetails.getCell(r, c);
          const v = cell.value === null || cell.value === undefined ? '' : String(cell.value);
          maxLen = Math.max(maxLen, v.length);
        }
        // add padding
        const width = Math.min(Math.max(maxLen + 2, 6), 50);
        wsDetails.getColumn(c).width = width;
      }

      // Ensure there's a blank column after the last column (skip one column after data)
      wsDetails.getColumn(lastCol + 1).width = 4;

      // Outer border: medium border around the occupied data area (header..lastDataRow, firstCol..lastCol)
      for (let r = headerRowIndex; r <= lastDataRow; r++) {
        for (let c = firstCol; c <= lastCol; c++) {
          const cell = wsDetails.getCell(r, c);
          const border = { ...cell.border };
          if (r === headerRowIndex) border.top = { style: 'medium' };
          if (r === lastDataRow) border.bottom = { style: 'medium' };
          if (c === firstCol) border.left = { style: 'medium' };
          if (c === lastCol) border.right = { style: 'medium' };
          cell.border = border;
        }
      }

      // Page setup similar to before
      wsDetails.pageSetup = {
        horizontalCentered: true,
        verticalCentered: false,
        orientation: 'landscape',
        fitToPage: true,
        fitToWidth: 1,
        fitToHeight: 0,
        margins: { left: 0.5, right: 0.5, top: 0.75, bottom: 0.75, header: 0.3, footer: 0.3 }
      };

      // ---------- SHEET 2: WU Summary ----------
      const ws = wb.addWorksheet('WU Summary');
      // reuse same offset logic for summary sheet
      const sOffsetRow = 2;
      const sOffsetCol = 2;
      const sFirstCol = sOffsetCol;
      // Header cols: Country, City, Employee, Contractors, Total
      const sHeaders = ['Country', 'City', 'Employee', 'Contractors', 'Total'];
      const sLastCol = sFirstCol + sHeaders.length - 1;

      // Title at offsetRow (merged + coloured + thick border)
      ws.mergeCells(`${colLetter(sFirstCol)}${sOffsetRow}:${colLetter(sLastCol)}${sOffsetRow}`);
      const sDateCell = ws.getCell(sOffsetRow, sFirstCol);
      sDateCell.value = format(pickedDate, 'EEEE, d MMMM, yyyy');
      sDateCell.alignment = { horizontal: 'center', vertical: 'middle' };
      // Colour & font for summary title (black bg, yellow text)
      for (let c = sFirstCol; c <= sLastCol; c++) {
        const cell = ws.getCell(sOffsetRow, c);
        cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF000000' } };
        cell.font = { name: 'Calibri', size: 12, bold: true, color: { argb: 'FFFFC107' } };
        // thick border around title row
        cell.border = { top: { style: 'medium' }, bottom: { style: 'medium' }, left: { style: 'medium' }, right: { style: 'medium' } };
      }
      ws.getRow(sOffsetRow).height = 22;

      const sHeaderRowIndex = sOffsetRow + 1;
      // set header row height
      ws.getRow(sHeaderRowIndex).height = 22;

      // write header values
      sHeaders.forEach((h, idx) => {
        const c = sFirstCol + idx;
        const cell = ws.getCell(sHeaderRowIndex, c);
        cell.value = h;
        cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFC107' } };
        cell.font = { name: 'Calibri', size: 11, bold: true };
        cell.alignment = { horizontal: 'center', vertical: 'middle' };
        // medium border for header
        cell.border = { top: { style: 'medium' }, left: { style: 'medium' }, bottom: { style: 'medium' }, right: { style: 'medium' } };
      });

      // Data rows start
      const sDataStartRow = sHeaderRowIndex + 1;
      partitionRows.forEach((r, i) => {
        const rowIndex = sDataStartRow + i;
        ws.getRow(rowIndex).height = 22; // set data row height to 22
        sHeaders.forEach((_, idx) => {
          const c = sFirstCol + idx;
          const cell = ws.getCell(rowIndex, c);
          const val = idx === 0 ? (r.country || '') : idx === 1 ? (r.city || '') : idx === 2 ? (r.employee || 0) : idx === 3 ? (r.contractor || 0) : (r.total || 0);
          cell.value = val;
          // numeric columns center + number format
          const isNumeric = idx >= 2;
          cell.alignment = { horizontal: 'center', vertical: 'middle' };
          if (isNumeric && typeof val === 'number') cell.numFmt = '#,##0';
          // thin border
          cell.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
          cell.font = { name: 'Calibri', size: 10 };
        });
      });

      // totals row: add thick border + coloured background (dark gray with white text)
      const sLastDataRow = (partitionRows?.length ? sDataStartRow + partitionRows.length - 1 : sHeaderRowIndex);
      const totalsRowIndex = sLastDataRow + 1;
      const totalEmployees = (partitionRows || []).reduce((s, r) => s + (r.employee || 0), 0);
      const totalContractors = (partitionRows || []).reduce((s, r) => s + (r.contractor || 0), 0);
      const totalTotals = (partitionRows || []).reduce((s, r) => s + (r.total || 0), 0);

      const totalsFill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF666666' } };
      const totalsFont = { name: 'Calibri', size: 11, bold: true, color: { argb: 'FFFFFFFF' } };

      // write totals cells and style
      for (let c = sFirstCol; c <= sLastCol; c++) {
        const cell = ws.getCell(totalsRowIndex, c);
        if (c === sFirstCol) cell.value = 'Total';
        else if (c === sFirstCol + 2) cell.value = totalEmployees;
        else if (c === sFirstCol + 3) cell.value = totalContractors;
        else if (c === sFirstCol + 4) cell.value = totalTotals;
        cell.fill = totalsFill;
        cell.font = totalsFont;
        cell.alignment = { horizontal: 'center', vertical: 'middle' };
        // medium border around totals row
        cell.border = { top: { style: 'medium' }, left: { style: 'medium' }, bottom: { style: 'medium' }, right: { style: 'medium' } };
        if ((c === sFirstCol + 2 || c === sFirstCol + 3 || c === sFirstCol + 4) && typeof cell.value === 'number') {
          cell.numFmt = '#,##0';
        }
      }
      ws.getRow(totalsRowIndex).height = 22;

      // --- NEW: Ensure full outside medium border around WU Summary occupied area (title..totals)
      for (let r = sOffsetRow; r <= totalsRowIndex; r++) {
        for (let c = sFirstCol; c <= sLastCol; c++) {
          const cell = ws.getCell(r, c);
          const border = { ...cell.border };
          if (r === sOffsetRow) border.top = { style: 'medium' };
          if (r === totalsRowIndex) border.bottom = { style: 'medium' };
          if (c === sFirstCol) border.left = { style: 'medium' };
          if (c === sLastCol) border.right = { style: 'medium' };
          cell.border = border;
        }
      }

      // add one blank row & blank column after data
      const blank = ws.addRow([]);
      blank.height = 22;
      ws.getColumn(sLastCol + 1).width = 4;

      // hide gridlines & freeze
      ws.views = [{ state: 'frozen', ySplit: sHeaderRowIndex, showGridLines: false }];

      // autosize for summary sheet (sFirstCol..sLastCol)
      for (let c = sFirstCol; c <= sLastCol; c++) {
        let maxLen = 0;
        for (let r = sOffsetRow; r <= totalsRowIndex; r++) {
          const v = ws.getCell(r, c).value === undefined || ws.getCell(r, c).value === null ? '' : String(ws.getCell(r, c).value);
          maxLen = Math.max(maxLen, v.length);
        }
        ws.getColumn(c).width = Math.min(Math.max(maxLen + 2, 6), 40);
      }

      ws.pageSetup = {
        orientation: 'landscape',
        fitToPage: true,
        fitToWidth: 1,
        fitToHeight: 0,
        horizontalCentered: true,
        verticalCentered: false,
        margins: { left: 0.5, right: 0.5, top: 0.75, bottom: 0.75, header: 0.3, footer: 0.3 }
      };

      // save file (filename logic preserved)
      let cityName = '';
      if (backendFilterKey) {
        const fe = Object.keys(apacPartitionDisplay).find(
          code => apacForwardKey[code] === backendFilterKey || code === backendFilterKey
        );
        cityName = fe ? apacPartitionDisplay[fe].city : backendFilterKey;
      }
      const filename = cityName
        ? `Western Union APAC (${cityName}) Headcount Report - ${format(pickedDate, 'd MMMM yyyy')}.xlsx`
        : `Western Union APAC Headcount Report - ${format(pickedDate, 'd MMMM yyyy')}.xlsx`;

      const buf = await wb.xlsx.writeBuffer();
      saveAs(new Blob([buf]), filename);

    } catch (err) {
      console.error('handleExport error:', err);
    }
  };

  /* ------------------ handleExportSummary ------------------ */
  const handleExportSummary = async () => {
    if (!pickedDate) return;

    const wb = new ExcelJS.Workbook();
    const ws = wb.addWorksheet('Summary');

    const offsetRow = 2;
    const offsetCol = 2;
    const firstCol = offsetCol;
    const headers = ['Country', 'City', 'Employees', 'Contractors', 'Total'];
    const lastCol = firstCol + headers.length - 1;

    // Title (merged) with colour + thick border
    ws.mergeCells(`${colLetter(firstCol)}${offsetRow}:${colLetter(lastCol)}${offsetRow}`);
    for (let c = firstCol; c <= lastCol; c++) {
      const cell = ws.getCell(offsetRow, c);
      cell.value = c === firstCol ? format(pickedDate, 'EEEE, d MMMM, yyyy') : ''; // only set on first, merged will show
      cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF000000' } }; // black
      cell.font = { name: 'Calibri', size: 14, bold: true, color: { argb: 'FFFFC107' } }; // yellow text
      cell.alignment = { horizontal: 'center', vertical: 'middle' };
      // thick border around title row
      cell.border = { top: { style: 'medium' }, bottom: { style: 'medium' }, left: { style: 'medium' }, right: { style: 'medium' } };
    }
    ws.getRow(offsetRow).height = 22;

    // Header row
    const headerRowIndex = offsetRow + 1;
    headers.forEach((h, idx) => {
      const c = firstCol + idx;
      const cell = ws.getCell(headerRowIndex, c);
      cell.value = h;
      cell.height = 22;
      cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFC107' } };
      cell.font = { name: 'Calibri', size: 12, bold: true, color: { argb: 'FF000000' } };
      cell.alignment = { horizontal: 'center', vertical: 'middle' };
      // medium border for header
      cell.border = { top: { style: 'medium' }, left: { style: 'medium' }, bottom: { style: 'medium' }, right: { style: 'medium' } };
    });
    ws.getRow(headerRowIndex).height = 22;

    // Data rows
    const dataStartRow = headerRowIndex + 1;
    partitionRows.forEach((r, i) => {
      const rowIndex = dataStartRow + i;
      ws.getRow(rowIndex).height = 22; // set every data row to 22
      headers.forEach((_, idx) => {
        const c = firstCol + idx;
        const cell = ws.getCell(rowIndex, c);
        const val = idx === 0 ? (r.country || '') : idx === 1 ? (r.city || '') : idx === 2 ? (r.employee || 0) : idx === 3 ? (r.contractor || 0) : (r.total || 0);
        cell.value = val;
        cell.alignment = { horizontal: 'center', vertical: 'middle' };
        if (idx >= 2 && typeof val === 'number') cell.numFmt = '#,##0';
        cell.font = { name: 'Calibri', size: 10 };
        cell.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
      });
    });

    // Totals row: thick border + coloured background
    const lastDataRow = (partitionRows?.length ? dataStartRow + partitionRows.length - 1 : headerRowIndex);
    const totalsRowIndex = lastDataRow + 1;
    const totalEmployees = partitionRows.reduce((s, r) => s + r.employee, 0);
    const totalContractors = partitionRows.reduce((s, r) => s + r.contractor, 0);
    const totalTotal = partitionRows.reduce((s, r) => s + r.total, 0);

    const totalsFill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF666666' } };
    const totalsFont = { name: 'Calibri', size: 11, bold: true, color: { argb: 'FFFFFFFF' } };

    for (let c = firstCol; c <= lastCol; c++) {
      const cell = ws.getCell(totalsRowIndex, c);
      if (c === firstCol) cell.value = 'Total';
      if (c === firstCol + 2) cell.value = totalEmployees;
      if (c === firstCol + 3) cell.value = totalContractors;
      if (c === firstCol + 4) cell.value = totalTotal;
      cell.fill = totalsFill;
      cell.font = totalsFont;
      cell.alignment = { horizontal: 'center', vertical: 'middle' };
      cell.border = { top: { style: 'medium' }, left: { style: 'medium' }, bottom: { style: 'medium' }, right: { style: 'medium' } };
      if ((c === firstCol + 2 || c === firstCol + 3 || c === firstCol + 4) && typeof cell.value === 'number') {
        cell.numFmt = '#,##0';
      }
    }
    ws.getRow(totalsRowIndex).height = 22;

    // --- NEW: Ensure full outside medium border around Summary area (title..totals)
    for (let r = offsetRow; r <= totalsRowIndex; r++) {
      for (let c = firstCol; c <= lastCol; c++) {
        const cell = ws.getCell(r, c);
        const border = { ...cell.border };
        if (r === offsetRow) border.top = { style: 'medium' };
        if (r === totalsRowIndex) border.bottom = { style: 'medium' };
        if (c === firstCol) border.left = { style: 'medium' };
        if (c === lastCol) border.right = { style: 'medium' };
        cell.border = border;
      }
    }

    // add blank row after and blank column after
    const blankRow = ws.addRow([]);
    blankRow.height = 22;
    ws.getColumn(lastCol + 1).width = 4;

    // hide gridlines & freeze header
    ws.views = [{ state: 'frozen', ySplit: headerRowIndex, showGridLines: false }];

    // autosize columns
    for (let c = firstCol; c <= lastCol; c++) {
      let maxLen = 0;
      for (let r = offsetRow; r <= totalsRowIndex; r++) {
        const v = ws.getCell(r, c).value === undefined || ws.getCell(r, c).value === null ? '' : String(ws.getCell(r, c).value);
        maxLen = Math.max(maxLen, v.length);
      }
      ws.getColumn(c).width = Math.min(Math.max(maxLen + 2, 6), 40);
    }

    // export
    const buf = await wb.xlsx.writeBuffer();
    const safeDate = format(pickedDate, 'yyyyMMdd');
    const filename = `apac_summary_${safeDate}.xlsx`;
    saveAs(new Blob([buf]), filename);
  };

  /* ------------------ handleExportCompanies ------------------ */
  const handleExportCompanies = async () => {
    if (!pickedDate || !companyRows.length) return;

    const wb = new ExcelJS.Workbook();
    const ws = wb.addWorksheet('Company Summary');

    const offsetRow = 2;
    const offsetCol = 2;
    const firstCol = offsetCol;
    const headers = ['Country', 'City', 'Company', 'Total'];
    const lastCol = firstCol + headers.length - 1;

    // Title (merged) with colour + thick border
    ws.mergeCells(`${colLetter(firstCol)}${offsetRow}:${colLetter(lastCol)}${offsetRow}`);
    for (let c = firstCol; c <= lastCol; c++) {
      const cell = ws.getCell(offsetRow, c);
      cell.value = c === firstCol ? format(pickedDate, 'EEEE, d MMMM, yyyy') : '';
      cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF000000' } };
      cell.font = { name: 'Calibri', size: 14, bold: true, color: { argb: 'FFFFC107' } };
      cell.alignment = { horizontal: 'center', vertical: 'middle' };
      cell.border = { top: { style: 'medium' }, bottom: { style: 'medium' }, left: { style: 'medium' }, right: { style: 'medium' } };
    }
    ws.getRow(offsetRow).height = 22;

    // header row
    const headerRowIndex = offsetRow + 1;
    headers.forEach((h, idx) => {
      const c = firstCol + idx;
      const cell = ws.getCell(headerRowIndex, c);
      cell.value = h;
      cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFC107' } };
      cell.font = { name: 'Calibri', size: 11, bold: true, color: { argb: 'FF000000' } };
      cell.alignment = { horizontal: 'center', vertical: 'middle' };
      cell.border = { top: { style: 'medium' }, left: { style: 'medium' }, bottom: { style: 'medium' }, right: { style: 'medium' } };
    });
    ws.getRow(headerRowIndex).height = 22;

    // data rows
    const dataStartRow = headerRowIndex + 1;
    companyRows.forEach((r, i) => {
      const rowIndex = dataStartRow + i;
      ws.getRow(rowIndex).height = 22;
      const rowValues = [r.country, r.city, r.company, r.total];
      rowValues.forEach((val, idx) => {
        const c = firstCol + idx;
        const cell = ws.getCell(rowIndex, c);
        cell.value = val;
        cell.border = { top: { style: 'thin' }, left: { style: 'thin' }, bottom: { style: 'thin' }, right: { style: 'thin' } };
        cell.alignment = { horizontal: 'center', vertical: 'middle' };
        if (idx === 3 && typeof val === 'number') cell.numFmt = '#,##0';
        cell.font = { name: 'Calibri', size: 10 };
      });
    });

    // totals row: thick border + coloured background
    const lastDataRow = dataStartRow + companyRows.length - 1;
    const totalsRowIndex = lastDataRow + 1;
    const total = companyRows.reduce((s, r) => s + r.total, 0);

    const totalsFill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF666666' } };
    const totalsFont = { name: 'Calibri', size: 11, bold: true, color: { argb: 'FFFFFFFF' } };

    for (let c = firstCol; c <= lastCol; c++) {
      const cell = ws.getCell(totalsRowIndex, c);
      if (c === firstCol) cell.value = 'Total';
      if (c === firstCol + 3) cell.value = total;
      cell.fill = totalsFill;
      cell.font = totalsFont;
      cell.alignment = { horizontal: 'center', vertical: 'middle' };
      cell.border = { top: { style: 'medium' }, left: { style: 'medium' }, bottom: { style: 'medium' }, right: { style: 'medium' } };
      if (c === firstCol + 3 && typeof cell.value === 'number') cell.numFmt = '#,##0';
    }
    ws.getRow(totalsRowIndex).height = 22;

    // blank row/col after
    const blank2 = ws.addRow([]);
    blank2.height = 22;
    ws.getColumn(lastCol + 1).width = 4;

    // hide gridlines & freeze
    ws.views = [{ state: 'frozen', ySplit: headerRowIndex, showGridLines: false }];

    // autosize columns
    for (let c = firstCol; c <= lastCol; c++) {
      let maxLen = 0;
      for (let r = offsetRow; r <= totalsRowIndex; r++) {
        const v = ws.getCell(r, c).value === undefined || ws.getCell(r, c).value === null ? '' : String(ws.getCell(r, c).value);
        maxLen = Math.max(maxLen, v.length);
      }
      ws.getColumn(c).width = Math.min(Math.max(maxLen + 2, 6), 50);
    }

    // save
    const buf = await wb.xlsx.writeBuffer();
    saveAs(new Blob([buf]), `apac_companies_${format(pickedDate, "yyyyMMdd")}.xlsx`);
  };


  if (loading) return <LoadingSpinner />;
  if (!data) return null;

  const datePickerSx = {
    backgroundColor: '#000',
    '& .MuiOutlinedInput-notchedOutline': { borderColor: '#FFC107' },
    '&:hover .MuiOutlinedInput-notchedOutline': { borderColor: '#FFC107' },
    '& .MuiInputBase-input': { color: '#FFC107' },
    '& .MuiInputLabel-root': { color: '#FFC107' },
    '& .MuiInputAdornment-root svg': { color: '#FFC107' },
  };

  // const companyColSpan = selectedSummaryPartition ? 3 : 4;


  return (
    <>
      <Header />
      <Container maxWidth={false} disableGutters sx={{ pt: 2, pb: 4 }}>
        {/* ‣ Date & summary */}
        {pickedDate && summaryEntry ? (
          <Box display="flex" alignItems="flex-start" sx={{ px: 2, mb: 2, gap: 2 }}>

            <Box sx={{ width: { xs: '100%', sm: 200 } }}> {/* responsive width */}
              <LocalizationProvider dateAdapter={AdapterDateFns}>

                <DatePicker
                  label="Select date"
                  value={pickedDate}
                  onChange={d => { setPickedDate(d); setShowDetails(false); }}
                  renderInput={params => <TextField fullWidth {...params} sx={datePickerSx} />}
                  maxDate={subDays(new Date())}
                />

              </LocalizationProvider>
              <Button
                variant="outlined"
                sx={{ mt: 2, ml: { xs: 0, sm: 2 }, width: { xs: '100%', sm: 'auto' }, borderColor: '#FFC107', color: '#FFC107' }}
                onClick={async () => {
                  const backendKey = backendFilterKey || 'all';
                  clearHistoryCache(backendKey);
                  setLoading(true);
                  try {
                    const fresh = await fetchHistory(decodedPartition);
                    saveHistoryCache(backendKey, fresh);
                    // build index
                    const detailMap = new Map();
                    (fresh.details || []).forEach(r => {
                      const d = (r.LocaleMessageTime && r.LocaleMessageTime.slice(0, 10))
                        || (r.SwipeDate && r.SwipeDate.slice(0, 10))
                        || 'unknown';
                      if (!detailMap.has(d)) detailMap.set(d, []);
                      detailMap.get(d).push(r);
                    });
                    const summaryMap = new Map();
                    (fresh.summaryByDate || []).forEach(s => summaryMap.set((s.date || '').slice(0, 10), s));
                    setData(fresh);
                    setIndexByDate({ detailMap, summaryMap });
                  } catch (err) {
                    console.error('Manual refresh failed', err);
                  } finally {
                    setLoading(false);
                  }
                }}
              >
                Refresh History
              </Button>
            </Box>

            {/* Container for both tables side-by-side */}
            {/* <Box sx={{ display: 'flex', gap: 2, width: '100%', flexWrap: { xs: 'wrap', md: 'nowrap' } }}> */}
            <Box
              sx={{
                display: 'flex',
                gap: 2,
                width: '100%',
                flexWrap: { xs: 'wrap', md: 'nowrap' }, // stack on mobile
                overflowX: 'auto', // horizontal scroll if needed
              }}
            >
              {/* Left: existing summary table */}
              {/* <Box sx={{ flex: 1, minWidth: 320 }}> */}
              <Box sx={{ flex: 1, minWidth: { xs: '100%', sm: 320 } }}>
                <Paper elevation={3} sx={{ p: 3, border: '3px solid #000', borderRadius: 2 }}>
                  <TableContainer sx={{ maxHeight: 500, overflowY: 'auto' }}>
                    <Table sx={{ border: '2px solid #000' }} size="small">
                      <TableHead>
                        <TableRow>
                          <TableCell colSpan={5} align="center"
                            sx={{ fontWeight: 'bold', fontSize: 16, bgcolor: '#000', color: '#FFC107', border: '2px solid #000' }}>
                            {format(pickedDate, 'EEEE, d MMMM, yyyy')}
                          </TableCell>
                        </TableRow>

                        <TableRow sx={{ bgcolor: '#FFC107' }}>
                          {['Country', 'City', 'Employees', 'Contractors', 'Total'].map(h => {
                            // clickable personnel headers
                            if (h === 'Employees' || h === 'Contractors') {
                              const personnelType = h === 'Employees' ? 'Employee' : 'Contractor';
                              const isActive = selectedPersonnel === personnelType && !selectedSummaryPartition;
                              return (
                                <TableCell
                                  key={h}
                                  align="right"
                                  onClick={() => {
                                    if (isActive) {
                                      setSelectedPersonnel(null);
                                    } else {
                                      setSelectedPersonnel(personnelType);
                                      setSelectedSummaryPartition(null);
                                      setSelectedCompany(null);
                                      setShowDetails(true);
                                    }
                                  }}
                                  sx={{
                                    color: isActive ? '#fff' : '#000',
                                    fontWeight: 'bold',
                                    fontSize: 14,
                                    border: '2px solid #000',
                                    cursor: 'pointer',
                                    textAlign: 'right',
                                    bgcolor: isActive ? '#474747' : '#FFC107',
                                    '&:hover': { backgroundColor: isActive ? '#5a5a5a' : '#f2f2f2' }
                                  }}
                                >
                                  {h}
                                </TableCell>
                              );
                            }
                            // non-clickable headers
                            return (
                              <TableCell
                                key={h}
                                align={['Country', 'City'].includes(h) ? 'left' : 'right'}
                                sx={{ color: '#000', fontWeight: 'bold', fontSize: 14, border: '2px solid #000' }}
                              >
                                {h}
                              </TableCell>
                            );
                          })}
                        </TableRow>

                      </TableHead>
                      <TableBody>

                        {partitionRows.map((r, i) => {
                          const rowKey = `${r.country}||${r.city}`;
                          return (
                            <TableRow
                              key={i}
                              onClick={() => {
                                // set city filter when a partition is clicked
                                setSelectedSummaryPartition(rowKey);
                                setSelectedCompany(null);
                                setSelectedPersonnel(null);
                                setShowDetails(true);
                              }}
                              sx={{
                                cursor: 'pointer',
                                '&:hover': { backgroundColor: '#474747' },
                                ...(selectedSummaryPartition === rowKey ? { backgroundColor: '#474747' } : {})
                              }}
                              tabIndex={0}
                              role="button"
                              onKeyDown={(e) => {
                                if (e.key === 'Enter' || e.key === ' ') {
                                  e.preventDefault();
                                  if (selectedSummaryPartition === rowKey) {
                                    setSelectedSummaryPartition(null);
                                    setShowDetails(true);
                                  } else {
                                    setSelectedSummaryPartition(rowKey);
                                    setShowDetails(true);
                                  }
                                }
                              }}
                            >
                              <TableCell sx={{ border: '2px solid #000' }}>{r.country}</TableCell>
                              <TableCell sx={{ border: '2px solid #000' }}>{r.city}</TableCell>
                              <TableCell align="right" sx={{ border: '2px solid #000' }}>{r.employee}</TableCell>
                              <TableCell align="right" sx={{ border: '2px solid #000' }}>{r.contractor}</TableCell>
                              <TableCell align="right" sx={{ bgcolor: '#FFC107', fontWeight: 'bold', border: '2px solid #000' }}>
                                {r.total}
                              </TableCell>
                            </TableRow>
                          );
                        })}


                        <TableRow sx={{ bgcolor: '#666' }}>
                          <TableCell colSpan={2} align="right" sx={{ color: '#fff', fontWeight: 'bold', border: '2px solid #000' }}>
                            Total
                          </TableCell>
                          <TableCell align="right" sx={{ color: '#fff', fontWeight: 'bold', border: '2px solid #000' }}>
                            {partitionRows.reduce((s, r) => s + r.employee, 0)}
                          </TableCell>
                          <TableCell align="right" sx={{ color: '#fff', fontWeight: 'bold', border: '2px solid #000' }}>
                            {partitionRows.reduce((s, r) => s + r.contractor, 0)}
                          </TableCell>
                          <TableCell align="right" sx={{ color: '#fff', fontWeight: 'bold', bgcolor: '#333', border: '2px solid #000' }}>
                            {partitionRows.reduce((s, r) => s + r.total, 0)}
                          </TableCell>
                        </TableRow>
                      </TableBody>
                    </Table>
                  </TableContainer>
                </Paper>

                {/* <Box display="flex" justifyContent="center" sx={{ mt: 1 }}> */}
                <Box display="flex" justifyContent="center" flexWrap="wrap" sx={{ mt: 1, gap: 1 }}> {/* added flexWrap & gap */}
                  {/* <Button variant="contained" sx={{ bgcolor: '#FFC107', color: '#000' }} onClick={() => setShowDetails(v => !v)}> */}
                  <Button variant="contained" sx={{ bgcolor: '#FFC107', color: '#000' }} onClick={() => setShowDetails(v => !v)}>
                    {showDetails ? 'Hide Details' : 'See Details'}
                  </Button>
                  {showDetails && (
                    <Button variant="outlined" sx={{ ml: 2, borderColor: '#FFC107', color: '#FFC107' }}
                      onClick={handleExport}>
                      Export to Excel
                    </Button>
                  )}
                  <Button
                    variant="contained"
                    sx={{ ml: 2, bgcolor: '#FFC107', color: '#000' }}
                    onClick={handleExportSummary}
                  >
                    Export Summary to Excel
                  </Button>
                  {selectedSummaryPartition && (
                    <Button
                      variant="outlined"
                      sx={{ ml: 2, borderColor: '#090909ff', color: '#060606ff', bgcolor: '#f31408ff' }}
                      onClick={() => { setSelectedSummaryPartition(null); setSelectedCompany(null); setShowDetails(false); }}
                    >
                      Clear city filter
                    </Button>
                  )}
                </Box>



              </Box>

              {/* Right: NEW company-level table (same style) */}
              {/* <Box sx={{ flex: 1, minWidth: 320 }}> */}
              <Box sx={{ flex: 1, minWidth: { xs: '100%', sm: 320 } }}>
                <Paper elevation={3} sx={{ p: 3, border: '3px solid #000', borderRadius: 2 }}>
                  <TableContainer sx={{ maxHeight: 280, overflowY: 'auto' }}>
                    <Table sx={{ border: '2px solid #000' }} size="small">
                      <TableHead>
                        <TableRow>
                          <TableCell
                            colSpan={4}
                            align="center"
                            sx={{
                              fontWeight: "bold",
                              fontSize: 16,
                              bgcolor: "#000",
                              color: "#FFC107",
                              border: "2px solid #000",
                            }}
                          >
                            {format(pickedDate, "EEEE, d MMMM, yyyy")}
                          </TableCell>
                        </TableRow>

                        <TableRow sx={{ bgcolor: "#FFC107" }}>
                          <TableCell
                            align="left"
                            sx={{
                              color: "#000",
                              fontWeight: "bold",
                              fontSize: 14,
                              border: "2px solid #000",
                            }}
                          >
                            Country
                          </TableCell>

                          <TableCell
                            align="left"
                            sx={{
                              color: "#000",
                              fontWeight: "bold",
                              fontSize: 14,
                              border: "2px solid #000",
                            }}
                          >
                            City
                          </TableCell>

                          <TableCell
                            align="left"
                            sx={{
                              color: "#000",
                              fontWeight: "bold",
                              fontSize: 14,
                              border: "2px solid #000",
                            }}
                          >
                            Company
                          </TableCell>

                          <TableCell
                            align="center"
                            sx={{
                              color: "#000",
                              fontWeight: "bold",
                              fontSize: 14,
                              border: "2px solid #000",
                            }}
                          >
                            Total
                          </TableCell>
                        </TableRow>
                      </TableHead>

                      <TableBody>
                        {companyRows.length > 0 ? (
                          companyRows.map((r, i) => {
                            const rowKey = makeCompanyKey(r.country, r.city, r.company);
                            return (
                              <TableRow
                                key={`${r.company}-${i}`}
                                onClick={() => {
                                  if (selectedCompany === rowKey) {
                                    setSelectedCompany(null);
                                    setShowDetails(true);
                                  } else {
                                    setSelectedCompany(rowKey);
                                    setShowDetails(true);
                                  }
                                }}
                                sx={{
                                  cursor: "pointer",
                                  "&:hover": { backgroundColor: "#474747" },
                                  ...(selectedCompany === rowKey
                                    ? { backgroundColor: "#474747" }
                                    : {}),
                                }}
                                tabIndex={0}
                                role="button"
                                onKeyDown={(e) => {
                                  if (e.key === "Enter" || e.key === " ") {
                                    e.preventDefault();
                                    if (selectedCompany === rowKey) {
                                      setSelectedCompany(null);
                                      setShowDetails(true);
                                    } else {
                                      setSelectedCompany(rowKey);
                                      setShowDetails(true);
                                    }
                                  }
                                }}
                              >
                                <TableCell sx={{ border: "2px solid #000" }}>{r.country}</TableCell>
                                <TableCell sx={{ border: "2px solid #000" }}>{r.city}</TableCell>
                                <TableCell sx={{ border: "2px solid #000" }}>{r.company}</TableCell>
                                <TableCell
                                  align="right"
                                  sx={{
                                    bgcolor: "#FFC107",
                                    fontWeight: "bold",
                                    border: "2px solid #000",
                                  }}
                                >
                                  {r.total}
                                </TableCell>
                              </TableRow>
                            );
                          })
                        ) : (
                          <TableRow>
                            <TableCell
                              colSpan={4}
                              sx={{
                                border: "2px solid #000",
                                textAlign: "center",
                                color: "#666",
                                fontStyle: "italic",
                              }}
                            >
                              No records for this date.
                            </TableCell>
                          </TableRow>
                        )}

                        {/* ✅ Total Row */}
                        {companyRows.length > 0 && (
                          <TableRow sx={{ bgcolor: "#666" }}>
                            <TableCell
                              colSpan={3}
                              align="right"
                              sx={{
                                color: "#fff",
                                fontWeight: "bold",
                                border: "2px solid #000",
                                fontSize: 15,
                              }}
                            >
                              Total
                            </TableCell>
                            <TableCell
                              align="right"
                              sx={{
                                color: "#fff",
                                fontWeight: "bold",
                                bgcolor: "#333",
                                border: "2px solid #000",
                                fontSize: 15,
                              }}
                            >
                              {companyRows.reduce((s, r) => s + r.total, 0)}
                            </TableCell>
                          </TableRow>
                        )}
                      </TableBody>

                    </Table>
                  </TableContainer>
                </Paper>

                <Box display="flex" justifyContent="center" sx={{ mt: 1 }}>
                  <Button
                    variant="contained"
                    sx={{ bgcolor: '#FFC107', color: '#000' }}
                    onClick={handleExportCompanies}
                  >
                    Export Companies to Excel
                  </Button>


                </Box>

              </Box>

            </Box>

          </Box>
        ) : (
          <Box sx={{ px: 2, mb: 3 }}>
            <LocalizationProvider dateAdapter={AdapterDateFns}>
              <DatePicker
                label="Select date"
                value={pickedDate}
                onChange={d => { setPickedDate(d); setShowDetails(false); }}
                renderInput={params => <TextField fullWidth {...params} sx={datePickerSx} />}
                maxDate={subDays(new Date(), 1)}
              />

            </LocalizationProvider>
            {!pickedDate && (
              <Typography variant="body1" color="textSecondary" sx={{ mt: 2 }}>
                Please pick a date to view region summary.
              </Typography>
            )}
          </Box>
        )}
        {/* ‣ Details */}
        {showDetails && (
          // <Box display="flex" justifyContent="center" mb={0} sx={{ width: '100%' }}>
          //   <Paper elevation={1} sx={{ p: 1, width: '100%', border: '3px solid #000', borderRadius: 2 }}>
          <Box display="flex" justifyContent="center" mb={0} sx={{ width: '100%', overflowX: 'auto' }}>
            <Paper elevation={1} sx={{ p: 1, width: '100%', border: '3px solid #000', borderRadius: 2 }}>
              {detailRows.length > 0 ? (

                <Table sx={{ border: '2px solid #000', borderCollapse: 'collapse' }} size='small'>
                  <TableHead>
                    <TableRow sx={{ bgcolor: '#000' }}>
                      {[
                        'Sr', 'Date', 'Time',
                        'Employee ID', 'Card Number', 'Name', 'Personnel Type', 'CompanyName', 'PrimaryLocation',
                        'Door', 'Partition'
                      ].map(h => (
                        <TableCell key={h} align="center"
                          sx={{ color: '#FFC107', fontWeight: 'bold', fontSize: 14, border: '2px solid #000' }}>
                          {h}
                        </TableCell>
                      ))}
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    {detailRows.map((r, i) => (
                      <TableRow key={`${r.PersonGUID}-${i}`}>
                        <TableCell sx={{ border: '2px solid #000', whiteSpace: 'nowrap' }}>{i + 1}</TableCell>
                        <TableCell sx={{ border: '2px solid #000' }}>{r.LocaleMessageTime.slice(0, 10)}</TableCell>
                        <TableCell sx={{ border: '2px solid #000', whiteSpace: 'nowrap' }}>
                          {formatApiTime12(r.LocaleMessageTime)}
                        </TableCell>
                        <TableCell sx={{ border: '2px solid #000' }}>{r.EmployeeID}</TableCell>
                        <TableCell sx={{ border: '2px solid #000' }}>{r.CardNumber}</TableCell>
                        <TableCell sx={{ border: '2px solid #000' }}>{r.ObjectName1}</TableCell>
                        <TableCell sx={{ border: '2px solid #000' }}>{r.PersonnelType}</TableCell>
                        <TableCell sx={{ border: '2px solid #000' }}>{r.CompanyName}</TableCell>
                        <TableCell sx={{ border: '2px solid #000' }}>{r.PrimaryLocation}</TableCell>
                        <TableCell sx={{ border: '2px solid #000' }}>{r.Door}</TableCell>
                        <TableCell sx={{ border: '2px solid #000' }}>
                          {formatPartition(r.PartitionNameFriendly)}
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              ) : (
                <Typography variant="body2" sx={{ color: '#666', textAlign: 'center', mt: 2, fontStyle: 'italic' }}>
                  No swipe records found for this date.
                </Typography>
              )}
            </Paper>
          </Box>
        )}
      </Container>
      <Footer />
    </>
  );
}

